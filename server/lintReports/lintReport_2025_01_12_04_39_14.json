[{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\eslint-report.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\jest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\defect-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":187,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":187,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":271,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":271,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":481,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":481,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":702,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":702,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":787,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":787,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":966,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":966,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":1040,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":1040,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from \"@Utils/database.js\";\r\nimport { Request, Response } from \"express\";\r\nimport { createNotification } from \"@Controllers/util-controller.js\";\r\nimport { DefectStatus, ItemType, NotificationType } from \"@prisma/client\";\r\nimport fs from 'fs';\r\nimport path from \"path\";\r\n\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้าง Defect ใหม่\r\n * Input: \r\n * - (req as any).user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.body: { name: String, description: String, type: ItemType, status: DefectStatus, defectUserId: Int, patrolResultId: Int, supervisorId: Int }\r\n * - req.files: Array<Express.Multer.File> (ไฟล์รูปภาพใหม่)\r\n * Output: JSON object ข้อมูล Defect ที่ถูกสร้าง พร้อมกับอัปเดตสถานะของ patrolResult\r\n**/\r\nexport async function createDefect(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const {\r\n      name,\r\n      description,\r\n      type,\r\n      defectUserId,\r\n      patrolResultId,\r\n      supervisorId,\r\n    } = req.body;\r\n    const imageFiles = req.files as Express.Multer.File[]; // Cast to an array of Multer files\r\n\r\n    const validPatrol = await prisma.patrol.findFirst({\r\n      where: {\r\n        results: {\r\n          some: {\r\n            id: parseInt(patrolResultId),\r\n          },\r\n        },\r\n        patrolChecklists: {\r\n          some: {\r\n            userId: parseInt(userId),\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!validPatrol) {\r\n      res\r\n        .status(404)\r\n        .json({\r\n          message:\r\n            \"You are not associated with this Patrol or PatrolResult not found\",\r\n        });\r\n      return;\r\n    }\r\n\r\n    const newDefect = await prisma.defect.create({\r\n      data: {\r\n        name: name,\r\n        description: description,\r\n        type: type,\r\n        status: \"reported\" as DefectStatus,\r\n        startTime: new Date(),\r\n        user: { connect: { id: parseInt(defectUserId) } },\r\n        patrolResult: { connect: { id: parseInt(patrolResultId) } },\r\n      },\r\n    });\r\n\r\n    const updateResult = async (patrolResultId: string) => {\r\n      try {\r\n        const result = await prisma.patrolResult.findUnique({\r\n          where: {\r\n            id: parseInt(patrolResultId), // Ensure it's an Integer\r\n          },\r\n        });\r\n\r\n        if (!result) {\r\n          console.error(\"Patrol result not found\");\r\n          return;\r\n        }\r\n\r\n        const updatedResult = await prisma.patrolResult.update({\r\n          where: { id: parseInt(patrolResultId) },\r\n          data: {\r\n            status: false,\r\n          },\r\n        });\r\n\r\n        return updatedResult;\r\n      } catch (error) {\r\n        console.error(\"Error updating patrol result:\", error);\r\n      }\r\n    };\r\n    updateResult(patrolResultId);\r\n    if (Array.isArray(imageFiles)) {\r\n      for (const imageFile of imageFiles) {\r\n        const imagePath = imageFile.filename; // Get the path of each uploaded file\r\n        const image = await prisma.image.create({\r\n          data: {\r\n            path: imagePath,\r\n            updatedBy: parseInt(defectUserId),\r\n          },\r\n        });\r\n\r\n        if (image) {\r\n          await prisma.defectImage.create({\r\n            data: {\r\n              defectId: newDefect.id,\r\n              imageId: image.id,\r\n            },\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      console.error(\"No files uploaded or incorrect file structure.\");\r\n    }\r\n    const message = `report_defect`;\r\n    const supervisor = parseInt(supervisorId, 10);\r\n\r\n    await createNotification({\r\n      message: message,\r\n      type: \"request\" as NotificationType,\r\n      url: `/defect/${newDefect.id}`,\r\n      userId: supervisor,\r\n    });\r\n\r\n    let result = await prisma.defect.findFirst({\r\n      where: { id: newDefect.id },\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            patrol: {\r\n              select: {\r\n                id: true,\r\n                preset: {\r\n                  select: {\r\n                    title: true\r\n                  }\r\n                }\r\n              }\r\n            },\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  select: {\r\n                    name: true,\r\n                    supervisor: {\r\n                      select: {\r\n                        id: true,\r\n                        profile: {\r\n                          include: {\r\n                            image: true\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                  }\r\n                }\r\n\r\n              }\r\n            }\r\n          },\r\n        },\r\n        images: {\r\n          select: {\r\n            image: {\r\n              select: {\r\n                id: true,\r\n                path: true,\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    email: true,\r\n                    role: true,\r\n                    department: true,\r\n                    createdAt: true\r\n                  }\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    })\r\n\r\n    res.status(201).json(result);\r\n  } catch (err) {\r\n    res.status(500)\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Defect \r\n * Input: \r\n * - (req as any).user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.params: { id: Int} (ID ของ Defect)\r\n * Output: JSON object ข้อมูล Defect และข้อมูล patrolResult ที่เกี่ยวข้อง\r\n**/\r\nexport async function getDefect(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    const defect = await prisma.defect.findUnique({\r\n      where: {\r\n        id: Number(id),\r\n      },\r\n      include: {\r\n        images: {\r\n          include: {\r\n            image: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    role: true,\r\n                    email: true,\r\n                    createdAt: true,\r\n                    profile: {\r\n                      include: {\r\n                        image: true\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            profile: {\r\n              include: {\r\n                image: true\r\n              }\r\n            }\r\n          }\r\n        },\r\n        patrolResult: {\r\n          select: {\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  include: {\r\n                    supervisor: {\r\n                      select: {\r\n                        profile: true\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!defect) {\r\n      res.status(404).json({ message: \"Defect not found\" });\r\n      return;\r\n    }\r\n\r\n    let result = defect\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (err) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Defect ทั้งหมด\r\n * Input: \r\n * - (req as any).user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON array ข้อมูล Defect ทั้งหมด รวมถึงข้อมูล patrolResult และ user ที่เกี่ยวข้อง \r\n**/\r\nexport async function getAllDefects(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const { status, type, startDate, endDate, search } = req.query;\r\n    // สร้างเงื่อนไขหลัก\r\n    const whereConditions: any = {\r\n      patrolResult: {\r\n        itemZone: {\r\n          zone: {\r\n            supervisor: {\r\n              id: userId,\r\n            },\r\n          },\r\n        },\r\n      },\r\n    };\r\n\r\n    const andConditions: any[] = [];\r\n\r\n    // เงื่อนไขการกรองตาม status\r\n    if (status) {\r\n      andConditions.push(\r\n        { status: status }\r\n      );\r\n    }\r\n\r\n    // เงื่อนไขการกรองตาม preset\r\n    if (type) {\r\n      const typeArray = (type as string).split(\",\"); // แยกค่าด้วย comma\r\n      const orTypeConditions = typeArray.map((t) => ({ type: t })); // สร้าง array ของ OR เงื่อนไข\r\n\r\n      andConditions.push({ OR: orTypeConditions });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตามช่วงเวลา\r\n    if (startDate && endDate) {\r\n      const start = new Date(startDate as string);\r\n      const end = new Date(endDate as string);\r\n\r\n      if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\r\n        andConditions.push({\r\n          startTime: {\r\n            gte: start,\r\n            lte: end,\r\n          },\r\n        });\r\n      } else {\r\n        console.error('Invalid date range:', startDate, endDate);\r\n      }\r\n    }\r\n\r\n    // เงื่อนไขการค้นหา (search)\r\n    if (search) {\r\n      const searchId = parseInt(search as string, 10);\r\n\r\n      function mapSearchToStatus(search: string): DefectStatus | null {\r\n        const searchLower = search.toLowerCase();\r\n\r\n        // ตรวจสอบความใกล้เคียงกับค่าของ DefectStatus\r\n        if (searchLower.startsWith('rep')) {\r\n          return DefectStatus.reported;\r\n        } else if (searchLower.startsWith('in')) {\r\n          return DefectStatus.in_progress;\r\n        } else if (searchLower.startsWith('pe')) {\r\n          return DefectStatus.pending_inspection;\r\n        } else if (searchLower.startsWith('res')) {\r\n          return DefectStatus.resolved;\r\n        } else if (searchLower.startsWith('co')) {\r\n          return DefectStatus.completed;\r\n        }\r\n        // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n        return null;\r\n      }\r\n\r\n      function mapSearchToType(search: string): ItemType | null {\r\n        const searchLower = search.toLowerCase();\r\n\r\n        // ตรวจสอบความใกล้เคียงกับค่าของ DefectStatus\r\n        if (searchLower.startsWith('sa')) {\r\n          return ItemType.safety;\r\n        } else if (searchLower.startsWith('en')) {\r\n          return ItemType.environment;\r\n        } else if (searchLower.startsWith('ma')) {\r\n          return ItemType.maintenance;\r\n        }\r\n\r\n        // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n        return null;\r\n      }\r\n\r\n      const mappedStatus = mapSearchToStatus(search as string);\r\n      const mappedTypes = mapSearchToType(search as string);\r\n\r\n      const orConditions = [];\r\n\r\n      if (!isNaN(searchId)) {\r\n        orConditions.push({ id: searchId });\r\n      }\r\n\r\n      // ถ้า mappedStatus มีค่า (ค้นหาตรงกับสถานะ)\r\n      if (mappedStatus) {\r\n        orConditions.push({ status: mappedStatus as DefectStatus });\r\n      }\r\n\r\n      // ถ้า mappedTypes มีค่า (ค้นหาตรงกับชนิด)\r\n      if (mappedTypes) {\r\n        orConditions.push({ type: mappedTypes as ItemType });\r\n      }\r\n\r\n      // ถ้ามีค่า preset title\r\n      orConditions.push({\r\n        name: {\r\n          contains: search as string,\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        user: {\r\n          profile: {\r\n            name: {\r\n              contains: search as string,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // ถ้ามีเงื่อนไขใน OR ให้เพิ่มเข้าไปใน AND\r\n      if (orConditions.length > 0) {\r\n        andConditions.push({ OR: orConditions });\r\n      }\r\n    }\r\n\r\n    // ถ้ามีเงื่อนไขเพิ่มเติมให้เพิ่มเข้าไปใน AND\r\n    if (andConditions.length > 0) {\r\n      whereConditions.AND = andConditions;\r\n    }\r\n\r\n    const defects = await prisma.defect.findMany({\r\n      where: whereConditions,\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: true,\r\n              }\r\n            }\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            profile: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                tel: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        images: {\r\n          select: {\r\n            image: {\r\n              select: {\r\n                id: true,\r\n                path: true,\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    role: true,\r\n                    email: true,\r\n                    createdAt: true,\r\n                    profile: {\r\n                      select: {\r\n                        id: true,\r\n                        name: true,\r\n                        tel: true,\r\n                        image: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    let result = defects\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (err) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\nfunction getUploadsPath(): string {\r\n  const currentDir = process.cwd();\r\n  return path.join(currentDir, 'uploads'); // Adjust path as needed\r\n}\r\n\r\nconst uploadsPath = getUploadsPath();\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดต Defect \r\n * Input: \r\n * - (req as any).user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.params: { id: Int} (ID ของ Defect ที่จะอัปเดต)\r\n * - req.body: {name: String, description: String, type: ItemType, status: DefectStatus, defectUserId: Int, patrolResultId: Int }\r\n * - req.file: Array<Express.Multer.File> (ไฟล์รูปภาพใหม่)\r\n * Output: JSON object ข้อมูล Defect หลังการอัปเดต\r\n**/\r\nexport async function updateDefect(req: Request, res: Response): Promise<void> {\r\n  try {\r\n    const { id } = req.params;\r\n    const {\r\n      name,\r\n      description,\r\n      type,\r\n      status,\r\n      defectUserId,\r\n      supervisorId,\r\n      patrolResultId,\r\n    } = req.body;\r\n    const newImageFiles = req.files as Express.Multer.File[];\r\n\r\n    const defect = await prisma.defect.findUnique({\r\n      where: { id: Number(id) },\r\n    });\r\n    if (!defect) {\r\n      res.status(404).json({ message: 'Defect not found' });\r\n      return;\r\n    }\r\n\r\n    if (newImageFiles?.length) {\r\n      const existingDefectImages = await prisma.defectImage.findMany({\r\n        where: { defectId: Number(id) },\r\n        select: { imageId: true },\r\n      });\r\n\r\n      if (status === 'edit' as DefectStatus) {\r\n        const imageIdsToDelete = existingDefectImages.map((img) => img.imageId);\r\n\r\n        const imagesToDelete = await prisma.image.findMany({\r\n          where: { id: { in: imageIdsToDelete } },\r\n          select: { path: true },\r\n        });\r\n\r\n        for (const image of imagesToDelete) {\r\n          const filePath = path.join(uploadsPath, image.path);\r\n          try {\r\n            fs.unlinkSync(filePath);\r\n          } catch (err) {\r\n            console.error(`Failed to delete file at ${filePath}:`, err);\r\n          }\r\n        }\r\n        await prisma.defectImage.deleteMany({\r\n          where: { defectId: Number(id) },\r\n        });\r\n        await prisma.image.deleteMany({\r\n          where: { id: { in: imageIdsToDelete } },\r\n        });\r\n      }\r\n\r\n      for (const file of newImageFiles) {\r\n        const image = await prisma.image.create({\r\n          data: {\r\n            path: file.filename,\r\n            updatedBy: parseInt(status === 'edit' as DefectStatus ? defectUserId : supervisorId, 10),\r\n          },\r\n        });\r\n        await prisma.defectImage.create({\r\n          data: {\r\n            defectId: Number(id),\r\n            imageId: image.id,\r\n          },\r\n        });\r\n      }\r\n    }\r\n\r\n    const updateData: any = {};\r\n\r\n    if (name !== undefined) updateData.name = name;\r\n    if (description !== undefined) updateData.description = description;\r\n    if (type !== undefined) updateData.type = type;\r\n    if (status !== undefined) updateData.status = status;\r\n\r\n    if (defectUserId !== undefined) {\r\n      updateData.user = { connect: { id: parseInt(defectUserId, 10) } };\r\n    }\r\n\r\n    if (patrolResultId !== undefined) {\r\n      updateData.patrolResult = { connect: { id: parseInt(patrolResultId, 10) } };\r\n    }\r\n\r\n    // ทำการอัปเดต Defect ด้วยข้อมูลที่มี\r\n    await prisma.defect.update({\r\n      where: { id: Number(id) },\r\n      data: updateData,\r\n    });\r\n\r\n\r\n\r\n    let message = null;\r\n    let notiType = null;\r\n    let url = null;\r\n    let receive = null;\r\n\r\n    if (status === 'in_progress' as DefectStatus) {\r\n      message = 'defect_accept',\r\n      notiType = \"information\" as NotificationType\r\n      url = `/patrol-defect`\r\n      receive = defectUserId\r\n    } else if (status === 'resolved' as DefectStatus) {\r\n      message = 'defect_resolved'\r\n      notiType = \"information\" as NotificationType\r\n      url = `/patrol-defect`\r\n      receive = defectUserId\r\n    } else if (status === 'pending_inspection' as DefectStatus) {\r\n      message = 'defect_pending_inspection'\r\n      notiType = \"request\" as NotificationType\r\n      url = `/defect/${id}`\r\n      receive = supervisorId\r\n    } else if (status === 'completed' as DefectStatus) {\r\n      message = 'defect_completed'\r\n      notiType = \"information\" as NotificationType\r\n      url = `/defect/${id}`\r\n      receive = supervisorId\r\n    }\r\n\r\n    if (message) {\r\n      await createNotification({\r\n        message,\r\n        type: notiType,\r\n        url,\r\n        userId: parseInt(receive),\r\n      });\r\n    }\r\n\r\n    const result = await prisma.defect.findUnique({\r\n      where: { id: Number(id) },\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            patrol: {\r\n              select: {\r\n                id: true,\r\n                preset: {\r\n                  select: {\r\n                    title: true\r\n                  }\r\n                }\r\n              }\r\n            },\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  select: {\r\n                    name: true,\r\n                    supervisor: {\r\n                      select: {\r\n                        id: true,\r\n                        profile: {\r\n                          include: {\r\n                            image: true\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          },\r\n        },\r\n        images: {\r\n          select: {\r\n            image: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    email: true,\r\n                    role: true,\r\n                    department: true,\r\n                    createdAt: true\r\n                  }\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            profile: {\r\n              include: {\r\n                image: true\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n    })\r\n\r\n    res.status(200).json(result);\r\n  } catch (err) {\r\n    res.status(500)\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบ Defect \r\n * Input: \r\n * - (req as any).user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.params: { id: Int} (ID ของ Defect ที่จะลบ)\r\n * Output: JSON message ยืนยันการลบ Defect สำเร็จ\r\n**/\r\nexport async function deleteDefect(req: Request, res: Response): Promise<void> {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n\r\n    const { id } = req.params;\r\n\r\n    const defect = await prisma.defect.findUnique({\r\n      where: {\r\n        id: Number(id),\r\n      },\r\n    });\r\n\r\n    if (!defect) {\r\n      res.status(404).json({ message: \"Defect not found\" });\r\n      return;\r\n    }\r\n    const existingDefectImages = await prisma.defectImage.findMany({\r\n      where: { defectId: Number(id) },\r\n      select: { imageId: true },\r\n    });\r\n\r\n    const imageIdsToDelete = existingDefectImages.map((img) => img.imageId);\r\n\r\n    const imagesToDelete = await prisma.image.findMany({\r\n      where: { id: { in: imageIdsToDelete } },\r\n      select: { path: true },\r\n    });\r\n\r\n    for (const image of imagesToDelete) {\r\n      const filePath = path.join(uploadsPath, image.path);\r\n      try {\r\n        fs.unlinkSync(filePath);\r\n      } catch (err) {\r\n        console.error(`Failed to delete file at ${filePath}:`, err);\r\n      }\r\n    }\r\n\r\n    await prisma.defectImage.deleteMany({\r\n      where: { defectId: Number(id) },\r\n    });\r\n    await prisma.image.deleteMany({\r\n      where: { id: { in: imageIdsToDelete } },\r\n    });\r\n\r\n    const validPatrol = await prisma.patrol.findFirst({\r\n      where: {\r\n        results: {\r\n          some: {\r\n            id: defect.patrolResultId,\r\n          },\r\n        },\r\n        patrolChecklists: {\r\n          some: {\r\n            userId: userId,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!validPatrol) {\r\n      res\r\n        .status(404)\r\n        .json({ message: \"You are not associated with this Patrol\" });\r\n      return;\r\n    }\r\n\r\n    await prisma.defect.delete({\r\n      where: {\r\n        id: Number(id),\r\n      },\r\n    });\r\n    res.status(200).json({ message: \"Defect deleted successfully\" });\r\n    return;\r\n  } catch (err) {\r\n    res.status(500);\r\n    return;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Comment ทั้งหมด\r\n * Input: \r\n * - (req as any).user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON array ข้อมูล Comment ทั้งหมด รวมถึงข้อมูล patrolResult และ user ที่เกี่ยวข้อง \r\n**/\r\nexport async function getAllComments(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const { status, startDate, endDate, search } = req.query;\r\n    // สร้างเงื่อนไขหลัก\r\n    const whereConditions: any = {\r\n      patrolResult: {\r\n        itemZone: {\r\n          zone: {\r\n            supervisor: {\r\n              id: userId,\r\n            },\r\n          },\r\n        },\r\n      },\r\n    };\r\n\r\n    const andConditions: any[] = [];\r\n\r\n    // เงื่อนไขการกรองตาม status\r\n    if (status !== undefined) {\r\n      const statusBoolean = status === 'true';\r\n      andConditions.push({ status: statusBoolean });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตามช่วงเวลา\r\n    if (startDate && endDate) {\r\n      const start = new Date(startDate as string);\r\n      const end = new Date(endDate as string);\r\n\r\n      if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\r\n        andConditions.push({\r\n          startTime: {\r\n            gte: start,\r\n            lte: end,\r\n          },\r\n        });\r\n      } else {\r\n        console.error('Invalid date range:', startDate, endDate);\r\n      }\r\n    }\r\n\r\n    // เงื่อนไขการค้นหา (search)\r\n    if (search) {\r\n      const searchId = parseInt(search as string, 10);\r\n\r\n      function mapSearchToStatus(search: string): boolean | null {\r\n        const searchLower = search.toLowerCase();\r\n\r\n        // ตรวจสอบความใกล้เคียงกับค่าของ CommentStatus\r\n        if (searchLower.startsWith('pe')) {\r\n          return false;\r\n        } else if (searchLower.startsWith('co')) {\r\n          return true;\r\n        }\r\n        // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n        return null;\r\n      }\r\n\r\n      const mappedStatus = mapSearchToStatus(search as string);\r\n\r\n      const orConditions = [];\r\n\r\n      if (!isNaN(searchId)) {\r\n        orConditions.push({ id: searchId });\r\n      }\r\n\r\n      // ถ้า mappedStatus มีค่า (ค้นหาตรงกับสถานะ)\r\n      if (mappedStatus != undefined) {\r\n        orConditions.push({ status: mappedStatus as boolean });\r\n      }\r\n\r\n      orConditions.push({\r\n        message: {\r\n          contains: search as string,\r\n        }\r\n      });\r\n\r\n      orConditions.push({\r\n        user: {\r\n          profile: {\r\n            name: {\r\n              contains: search as string,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        patrolResult: {\r\n          itemZone: {\r\n            zone: {\r\n              name: {\r\n                contains: search as string,\r\n              }\r\n            },\r\n          }\r\n        }\r\n      });\r\n\r\n      orConditions.push({\r\n        patrolResult: {\r\n          itemZone: {\r\n            item: {\r\n              name: {\r\n                contains: search as string,\r\n              }\r\n            },\r\n          }\r\n        }\r\n      });\r\n\r\n      // ถ้ามีเงื่อนไขใน OR ให้เพิ่มเข้าไปใน AND\r\n      if (orConditions.length > 0) {\r\n        andConditions.push({ OR: orConditions });\r\n      }\r\n    }\r\n\r\n    // ถ้ามีเงื่อนไขเพิ่มเติมให้เพิ่มเข้าไปใน AND\r\n    if (andConditions.length > 0) {\r\n      whereConditions.AND = andConditions;\r\n    }\r\n\r\n    // บันทึก query ที่สร้างขึ้นสำหรับการดีบัก\r\n\r\n    const comments = await prisma.comment.findMany({\r\n      where: whereConditions,\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: true,\r\n                item: {\r\n                  include: {\r\n                    checklist: true\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            profile: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                tel: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    let result = comments\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (err) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับยืนยัน Comment\r\n * Input:\r\n * - req.params.id: number (ID ของ Comment ที่ต้องการยืนยัน)\r\n * Output: JSON object ข้อมูล Comment หลังจากยืนยัน\r\n**/\r\nexport async function confirmComment(req: Request, res: Response) {\r\n  try {\r\n    const commentId = parseInt(req.params.id, 10);\r\n\r\n    await prisma.comment.update({\r\n      where: {\r\n        id: commentId,\r\n      },\r\n      data: {\r\n        status: true,\r\n      },\r\n    });\r\n\r\n    const result = await prisma.comment.findUnique({\r\n      where: {\r\n        id: commentId,\r\n      },\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: true,\r\n                item: {\r\n                  include: {\r\n                    checklist: true\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            profile: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                tel: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const message = `confirm_comment`;\r\n    await createNotification({\r\n      message: message,\r\n      type: \"information\" as NotificationType,\r\n      url: ``,\r\n      userId: result?.user.id,\r\n    });\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500);\r\n    return;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\location-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":43,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":65,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":114,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":185,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":185,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from '@Utils/database.js'\r\nimport { Request, Response } from 'express'\r\nimport { createNotification } from '@Controllers/util-controller.js'\r\nimport { NotificationType } from '@prisma/client'\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Zone\r\n * Input: \r\n * - (req.params.id): Int (ID ของ Zone)\r\n * Output: JSON object ข้อมูล Zone\r\n**/\r\nexport async function getZone(req: Request, res: Response) {\r\n    try {\r\n        const zoneId = parseInt(req.params.id, 10)\r\n        const zone = await prisma.zone.findUnique({\r\n            where: { id: zoneId },\r\n            include: {\r\n                supervisor: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true,\r\n                        email: true,\r\n                        role: true,\r\n                        department: true,\r\n                        createdAt: true,\r\n                        profile: {\r\n                            include: {\r\n                                image: true\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        if (!zone) {\r\n            res.status(404)\r\n            return\r\n        }\r\n        let result = zone;\r\n\r\n        res.status(200).json(result)\r\n        return\r\n    } catch (error) {\r\n        res.status(500)\r\n        return\r\n    }\r\n}\r\n\r\nexport async function getAllZone(req: Request, res: Response) {\r\n    try {\r\n        const zone = await prisma.zone.findMany({\r\n            select: {\r\n               id:true,\r\n               name:true,\r\n            }\r\n        })\r\n        if (!zone) {\r\n            res.status(404)\r\n            return\r\n        }\r\n        let result = zone;\r\n\r\n        res.status(200).json(result)\r\n        return\r\n    } catch (error) {\r\n        res.status(500)\r\n        return\r\n    }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Location\r\n * Input: \r\n * - (req.params.id): Int (ID ของ Location)\r\n * Output: JSON object ข้อมูล Location\r\n**/\r\nexport async function getLocation(req: Request, res: Response) {\r\n    try {\r\n        const id = parseInt(req.params.id, 10);\r\n        const location = await prisma.location.findUnique({\r\n            where: { id: id },\r\n            include: {\r\n                zones: {\r\n                    include: {\r\n                        supervisor: {\r\n                            select: {\r\n                                id: true,\r\n                                username: true,\r\n                                email: true,\r\n                                role: true,\r\n                                department: true,\r\n                                createdAt: true,\r\n                                profile: {\r\n                                    include: {\r\n                                        image: true\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n            }\r\n        })\r\n\r\n        if (!location) {\r\n            res.status(404)\r\n            return\r\n        }\r\n\r\n        let result = location;\r\n\r\n        res.status(200).json(result)\r\n        return\r\n    } catch (error) {\r\n        res.status(500)\r\n        return\r\n    }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับเปลี่ยน Supervisor\r\n * Input:\r\n * - req.params.id: number (ID ของ Zone ที่ต้องการเปลี่ยน Supervisor)\r\n * - req.body: {\r\n *     userId: number,\r\n * Output: JSON object ข้อมูล Zone หลังจาก update\r\n**/\r\nexport async function updateSupervisor(req: Request, res: Response) {\r\n    try {\r\n        const zoneId = parseInt(req.params.id, 10);\r\n        const { userId } = req.body;\r\n\r\n        const oldZone = await prisma.zone.findUnique({\r\n            where: { userId: userId },\r\n        });\r\n\r\n        if (oldZone && oldZone.id !== zoneId) {\r\n            await prisma.zone.update({\r\n                where: { id: oldZone.id },\r\n                data: { userId: null },\r\n            });\r\n        }\r\n\r\n        // อัปเดต zone\r\n        await prisma.zone.update({\r\n            where: { id: zoneId },\r\n            data: {\r\n                userId: userId ? parseInt(userId, 10) : null,\r\n            },\r\n        });\r\n\r\n        let result = await prisma.zone.findUnique({\r\n            where: {\r\n                id: zoneId\r\n            },\r\n            include: {\r\n                supervisor: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true,\r\n                        email: true,\r\n                        role: true,\r\n                        department: true,\r\n                        createdAt: true,\r\n                        profile: {\r\n                            include: {\r\n                                image: true\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n        });\r\n\r\n        const message = `update_supervisor-${result?.name}`;\r\n        await createNotification({\r\n            message: message,\r\n            type: \"information\" as NotificationType,\r\n            url: `/profile`,\r\n            userId: userId,\r\n        });\r\n\r\n        res.status(200).json(result);\r\n        return;\r\n    } catch (error) {\r\n        res.status(500);\r\n        return;\r\n    }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\patrol-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":127,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":349,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":349,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":396,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":396,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":550,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":550,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":718,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":718,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":890,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":890,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":928,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":928,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":1091,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":1091,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'supervisorId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1110,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":1110,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from \"@Utils/database.js\";\r\nimport { Request, Response } from \"express\";\r\nimport { createNotification } from \"@Controllers/util-controller.js\";\r\nimport { NotificationType, PatrolStatus, User } from \"@prisma/client\";\r\n\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Patrol ตาม ID\r\n * Input:\r\n * - req.query: { preset: \"true\" | \"false\", result: \"true\" | \"false\" } (optional)\r\n * - req.params.id: number (ID ของ Patrol ที่ต้องการดึงข้อมูล)\r\n * - req.user: { userId: number } (บทบาทและ ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON object ข้อมูล Patrol รวมถึง preset และ result หากร้องขอ\r\n**/\r\nexport async function getPatrol(req: Request, res: Response) {\r\n  try {\r\n    const includePreset = req.query.preset === \"true\";\r\n    const includeResult = req.query.result === \"true\";\r\n\r\n    const userId = (req as any).user.userId;\r\n    const patrolId = parseInt(req.params.id, 10);\r\n    let patrol: any;\r\n\r\n    patrol = await prisma.patrol.findFirst({\r\n      where: {\r\n        id: patrolId,\r\n        patrolChecklists: {\r\n          some: {\r\n            userId: userId,\r\n          },\r\n        },\r\n      },\r\n      include: {\r\n        preset: includePreset\r\n          ? {\r\n            select: {\r\n              id: true,\r\n              title: true,\r\n              description: true,\r\n            },\r\n          }\r\n          : undefined,\r\n        patrolChecklists: {\r\n          include: {\r\n            checklist: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                items: {\r\n                  include: {\r\n                    itemZones: {\r\n                      select: {\r\n                        zone: {\r\n                          select: {\r\n                            id: true,\r\n                            name: true,\r\n                            supervisor: {\r\n                              select: {\r\n                                id: true,\r\n                                profile: {\r\n                                  select: {\r\n                                    name: true,\r\n                                  },\r\n                                },\r\n                              },\r\n                            },\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            inspector: {\r\n              select: {\r\n                id: true,\r\n                email: true,\r\n                department: true,\r\n                role: true,\r\n                profile: {\r\n                  select: {\r\n                    name: true,\r\n                    image: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        results: includeResult\r\n          ? {\r\n            include: {\r\n              defects: true,\r\n              comments: {\r\n                include: {\r\n                  user: {\r\n                    select: {\r\n                      id: true,\r\n                      email: true,\r\n                      department: true,\r\n                      role: true,\r\n                      profile: {\r\n                        select: {\r\n                          name: true,\r\n                          image: true,\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          }\r\n          : undefined,\r\n      },\r\n    });\r\n\r\n    if (!patrol) {\r\n      res.status(404);\r\n      return;\r\n    }\r\n    let result = patrol;\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500);\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Patrol ทั้งหมดตามสถานะ\r\n * Input:\r\n * - req.query: { status, preset, startDate, endDate, search } (\"status\", \"preset\", \"startDate\", \"endDate\" ใช้สำหรับ filter ข้อมูล และ search ใช้สำหรับค้นหาชื่อ inspector หรืออื่นๆ )\r\n * - req.user: { userId: number } (บทบาทและ ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON array ข้อมูล Patrol และข้อมูลที่เกี่ยวข้อง\r\n**/\r\nexport async function getAllPatrols(req: Request, res: Response) {\r\n  try {\r\n    const { status, preset, startDate, endDate, search } = req.query;\r\n    const userId = (req as any).user.userId;\r\n    // สร้างเงื่อนไขหลัก\r\n    const whereConditions: any = {\r\n      patrolChecklists: {\r\n        some: {\r\n          userId: userId,\r\n        },\r\n      }\r\n    };\r\n\r\n    const andConditions: any[] = [];\r\n\r\n    // เงื่อนไขการกรองตาม status\r\n    if (status) {\r\n      const statusArray = (status as string).split(\",\"); // แยกค่าด้วย comma\r\n      const orStatusConditions = statusArray.map((s) => ({ status: s })); // สร้าง array ของ OR เงื่อนไข\r\n\r\n      andConditions.push({ OR: orStatusConditions });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตาม preset\r\n    if (preset) {\r\n      andConditions.push({\r\n        preset: {\r\n          title: { contains: preset as string }\r\n        }\r\n      });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตามช่วงเวลา\r\n    if (startDate && endDate) {\r\n      const start = new Date(startDate as string);\r\n      const end = new Date(endDate as string);\r\n\r\n      if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\r\n        andConditions.push({\r\n          date: {\r\n            gte: start,\r\n            lte: end,\r\n          },\r\n        });\r\n      } else {\r\n        console.error('Invalid date range:', startDate, endDate);\r\n      }\r\n    }\r\n\r\n    // เงื่อนไขการค้นหา (search)\r\n    if (search) {\r\n      const searchId = parseInt(search as string, 10);\r\n\r\n      function mapSearchToStatus(search: string): PatrolStatus | null {\r\n        const searchLower = search.toLowerCase();\r\n\r\n        // ตรวจสอบความใกล้เคียงกับค่าของ PatrolStatus\r\n        if (searchLower.startsWith('p')) {\r\n          return PatrolStatus.pending;\r\n        } else if (searchLower.startsWith('s')) {\r\n          return PatrolStatus.scheduled;\r\n        } else if (searchLower.startsWith('o')) {\r\n          return PatrolStatus.on_going;\r\n        } else if (searchLower.startsWith('c')) {\r\n          return PatrolStatus.completed;\r\n        }\r\n\r\n        // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n        return null;\r\n      }\r\n\r\n      const mappedStatus = mapSearchToStatus(search as string);\r\n\r\n      const orConditions = [];\r\n\r\n      if (!isNaN(searchId)) {\r\n        orConditions.push({ id: searchId });\r\n      }\r\n\r\n      // ถ้า mappedStatus มีค่า (ค้นหาตรงกับสถานะ)\r\n      if (mappedStatus) {\r\n        orConditions.push({ status: mappedStatus as PatrolStatus });\r\n      }\r\n\r\n      // ถ้ามีค่า preset title\r\n      orConditions.push({\r\n        preset: {\r\n          title: {\r\n            contains: search as string,\r\n          },\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        patrolChecklists: {\r\n          some: {\r\n            inspector: {\r\n              profile: {\r\n                name: {\r\n                  contains: search as string,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // ถ้ามีเงื่อนไขใน OR ให้เพิ่มเข้าไปใน AND\r\n      if (orConditions.length > 0) {\r\n        andConditions.push({ OR: orConditions });\r\n      }\r\n    }\r\n\r\n    // ถ้ามีเงื่อนไขเพิ่มเติมให้เพิ่มเข้าไปใน AND\r\n    if (andConditions.length > 0) {\r\n      whereConditions.AND = andConditions;\r\n    }\r\n\r\n    // บันทึก query ที่สร้างขึ้นสำหรับการดีบัก\r\n    // console.log('Generated Query:', JSON.stringify(whereConditions, null, 2));\r\n\r\n    const allPatrols = await prisma.patrol.findMany({\r\n      where: whereConditions,\r\n      select: {\r\n        id: true,\r\n        date: true,\r\n        status: true,\r\n        preset: {\r\n          select: {\r\n            id: true,\r\n            title: true,\r\n          },\r\n        },\r\n        patrolChecklists: {\r\n          include: {\r\n            checklist: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                items: {\r\n                  include: {\r\n                    itemZones: {\r\n                      select: {\r\n                        zone: {\r\n                          select: {\r\n                            id: true,\r\n                            name: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            inspector: {\r\n              select: {\r\n                id: true,\r\n                email: true,\r\n                profile: {\r\n                  include: {\r\n                    image: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    // จัดกลุ่ม patrols โดยใช้ id และรวม Inspectors และ Item Counts\r\n    const groupedPatrols: Record<number, any> = {};\r\n\r\n    allPatrols.forEach(patrol => {\r\n      if (!groupedPatrols[patrol.id]) {\r\n        groupedPatrols[patrol.id] = {\r\n          id: patrol.id,\r\n          date: patrol.date,\r\n          status: patrol.status,\r\n          preset: patrol.preset,\r\n          itemCounts: {},\r\n          inspectors: []\r\n        };\r\n      }\r\n\r\n      let count = 0\r\n      patrol.patrolChecklists.forEach(patrolChecklist => {\r\n        // นับจำนวน item แต่ละประเภท\r\n        patrolChecklist.checklist.items.forEach(item => {\r\n          item.itemZones.forEach(_itemZone => {\r\n            count++\r\n          })\r\n        });\r\n        groupedPatrols[patrol.id].itemCounts = count;\r\n\r\n        // เพิ่ม Inspector ถ้ายังไม่มีในรายการ\r\n        const inspector = patrolChecklist.inspector;\r\n        if (inspector && !groupedPatrols[patrol.id].inspectors.some((ins: any) => ins.id === inspector.id)) {\r\n          groupedPatrols[patrol.id].inspectors.push(inspector);\r\n        }\r\n      });\r\n    });\r\n\r\n    // แปลงกลุ่ม patrols เป็น array\r\n    const result = Object.values(groupedPatrols)\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\nexport async function getPatrolUser(req: Request, res: Response) {\r\n  try {\r\n    const patrolId = parseInt(req.params.id, 10);\r\n\r\n    const patrol = await prisma.patrol.findUnique({\r\n      where: {\r\n        id: patrolId,\r\n      },\r\n      select: {\r\n        patrolChecklists: {\r\n          select: {\r\n            inspector: {\r\n              select: {\r\n                id: true,\r\n                username: true,\r\n                profile: {\r\n                  select: {\r\n                    id: true,\r\n                    name: true,\r\n                    image: true\r\n                  }\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      }\r\n    });\r\n\r\n    let result: any[] = []\r\n    patrol?.patrolChecklists.map((pc) => {\r\n      result.push(pc.inspector)\r\n    })\r\n\r\n    // Remove duplicates by username\r\n    result = result.filter((user, index, self) =>\r\n      index === self.findIndex((u) => u.username === user.username)\r\n    )\r\n\r\n    res.status(200).json(result);\r\n    return\r\n  } catch (error) {\r\n    res.status(500);\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้าง Patrol ใหม่\r\n * Input:\r\n * - req.body: {\r\n *     date: String,\r\n *     presetId: number,\r\n *     checklists: Array<{ checklistId: number, userId: number }>\r\n *   } (ข้อมูล Patrol ที่ต้องการสร้าง)\r\n * Output: JSON object ข้อมูล Patrol ที่ถูกสร้าง\r\n**/\r\nexport async function createPatrol(req: Request, res: Response) {\r\n  try {\r\n    const { date, presetId, checklists } = req.body;\r\n\r\n    if (!date || !presetId || !checklists) {\r\n      res.status(400).json({ message: \"Missing required fields\" });\r\n      return;\r\n    }\r\n\r\n    const patrolDate = new Date(date);\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    patrolDate.setHours(0, 0, 0, 0);\r\n\r\n    const status =\r\n      patrolDate.getTime() === today.getTime() ? \"scheduled\" : \"pending\";\r\n\r\n    const newPatrol = await prisma.patrol.create({\r\n      data: {\r\n        date: patrolDate,\r\n        status: status,\r\n        presetId: parseInt(presetId, 10),\r\n      },\r\n    });\r\n\r\n    const notifiedInspectors = new Set<number>();\r\n\r\n    for (const checklist of checklists) {\r\n      const { checklistId, userId } = checklist;\r\n\r\n      if (!checklistId || !userId) {\r\n        continue;\r\n      }\r\n\r\n      await prisma.patrolChecklist.create({\r\n        data: {\r\n          patrolId: newPatrol.id,\r\n          checklistId: checklistId,\r\n          userId: userId,\r\n        },\r\n      });\r\n\r\n      if (!notifiedInspectors.has(userId)) {\r\n        const message = `patrol_assigned-${new Date(patrolDate).toISOString()}`;\r\n        await createNotification({\r\n          message: message,\r\n          type: \"request\" as NotificationType,\r\n          url: `/patrol/${newPatrol.id}/detail`,\r\n          userId: userId,\r\n        });\r\n\r\n        notifiedInspectors.add(userId);\r\n      }\r\n    }\r\n\r\n    // Fetch the created patrol with the desired format\r\n    const createdPatrol = await prisma.patrol.findUnique({\r\n      where: { id: newPatrol.id },\r\n      select: {\r\n        id: true,\r\n        date: true,\r\n        status: true,\r\n        preset: {\r\n          select: {\r\n            id: true,\r\n            title: true,\r\n          },\r\n        },\r\n        patrolChecklists: {\r\n          include: {\r\n            checklist: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                items: {\r\n                  include: {\r\n                    itemZones: {\r\n                      select: {\r\n                        zone: {\r\n                          select: {\r\n                            id: true,\r\n                            name: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            inspector: {\r\n              select: {\r\n                id: true,\r\n                email: true,\r\n                profile: {\r\n                  include: {\r\n                    image: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (createdPatrol) {\r\n      // Process data to group inspectors and count items\r\n      const result = {\r\n        id: createdPatrol.id,\r\n        date: createdPatrol.date,\r\n        status: createdPatrol.status,\r\n        preset: createdPatrol.preset,\r\n        itemCounts: 0,\r\n        inspectors: [] as any,\r\n      };\r\n\r\n      // Count items and group inspectors\r\n      createdPatrol.patrolChecklists.forEach((patrolChecklist) => {\r\n        // Count items\r\n        patrolChecklist.checklist.items.forEach((item) => {\r\n          result.itemCounts += item.itemZones.length;\r\n        });\r\n\r\n        // Add unique inspectors\r\n        const inspector = patrolChecklist.inspector;\r\n        if (\r\n          inspector &&\r\n          !result.inspectors.some((ins: User) => ins.id === inspector.id)\r\n        ) {\r\n          result.inspectors.push(inspector); // TypeScript จะเข้าใจประเภท inspector ชัดเจน\r\n        }\r\n\r\n\r\n      });\r\n      res.status(201).json(result);\r\n    }\r\n\r\n  } catch (error) {\r\n    res.status(500);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับเริ่มต้น Patrol\r\n * Input:\r\n * - req.params.id: number (ID ของ Patrol ที่ต้องการเริ่ม)\r\n * - req.body: {\r\n *     status: String,\r\n *     checklists: Array<{ checklist: { items: Array<{ itemZones: Array<{ zone: { id: number } }> }> }, inspector: { id: number } }>\r\n *   } (สถานะและรายการ Checklist)\r\n * - req.user: { userId: number } (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON object ข้อมูล Patrol หลังจากเริ่มต้น\r\n**/\r\nexport async function startPatrol(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const patrolId = parseInt(req.params.id, 10);\r\n    const { status, checklists } = req.body;\r\n\r\n    const isUserInspector = checklists.some((checklistObj: any) => {\r\n      return checklistObj.inspector.id === userId;\r\n    });\r\n\r\n    if (!isUserInspector) {\r\n      res.status(403).json({\r\n        message:\r\n          \"You are not authorized to start this patrol. Only assigned inspectors can start the patrol.\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (!status || !checklists || status !== \"scheduled\") {\r\n      res.status(400);\r\n      return;\r\n    }\r\n\r\n    await prisma.patrol.update({\r\n      where: {\r\n        id: patrolId,\r\n      },\r\n      data: {\r\n        status: \"on_going\",\r\n        startTime: new Date(),\r\n      },\r\n    });\r\n\r\n    const notifiedInspectors = new Set<number>();\r\n\r\n    for (const checklistObj of checklists) {\r\n      const inspectorId = checklistObj.inspector.id;\r\n\r\n      for (const items of checklistObj.checklist.items) {\r\n        for (const zones of items.itemZones) {\r\n          await prisma.patrolResult.create({\r\n            data: {\r\n              status: null,\r\n              itemId: items.id,\r\n              zoneId: zones.zone.id,\r\n              patrolId: patrolId,\r\n            },\r\n          });\r\n          if (!notifiedInspectors.has(inspectorId)) {\r\n            const message = `start_patrol`;\r\n            await createNotification({\r\n              message: message,\r\n              type: \"information\" as NotificationType,\r\n              url: `/patrol/${patrolId}/detail`,\r\n              userId: inspectorId,\r\n            });\r\n\r\n            notifiedInspectors.add(inspectorId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const updatePatrol = await prisma.patrol.findFirst({\r\n      where: {\r\n        id: patrolId,\r\n      },\r\n      include: {\r\n        preset: {\r\n          select: {\r\n            id: true,\r\n            title: true,\r\n            description: true,\r\n          },\r\n        },\r\n        patrolChecklists: {\r\n          include: {\r\n            checklist: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                items: {\r\n                  include: {\r\n                    itemZones: {\r\n                      select: {\r\n                        zone: {\r\n                          select: {\r\n                            id: true,\r\n                            name: true,\r\n                            supervisor: {\r\n                              select: {\r\n                                id: true,\r\n                                profile: {\r\n                                  select: {\r\n                                    name: true,\r\n                                  },\r\n                                },\r\n                              },\r\n                            },\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            inspector: {\r\n              select: {\r\n                id: true,\r\n                email: true,\r\n                department: true,\r\n                role: true,\r\n                profile: {\r\n                  select: {\r\n                    name: true,\r\n                    image: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        results: {\r\n          include: {\r\n            defects: true,\r\n            comments: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    email: true,\r\n                    department: true,\r\n                    role: true,\r\n                    profile: {\r\n                      select: {\r\n                        name: true,\r\n                        image: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    let result = updatePatrol;\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500);\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสิ้นสุด Patrol\r\n * Input:\r\n * - req.params.id: number (ID ของ Patrol ที่ต้องการสิ้นสุด)\r\n * - req.body: {\r\n *     status: String,\r\n *     checklist: Array<{ inspector: { id: number } }>,\r\n *     result: Array<{ id: number, status: String }>,\r\n *     startTime: String\r\n *   } (สถานะ, Checklist, ผลลัพธ์, และเวลาเริ่มต้น)\r\n * - req.user: { userId: number } (บทบาทและ ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON object ข้อมูล Patrol หลังจากสิ้นสุด\r\n**/\r\nexport async function finishPatrol(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const patrolId = parseInt(req.params.id, 10);\r\n    const { status, checklists, results, startTime } = req.body;\r\n\r\n    const isUserInspector = checklists.some((checklistObj: any) => {\r\n      return checklistObj.inspector.id === userId;\r\n    });\r\n\r\n    if (!isUserInspector) {\r\n      res.status(403).json({\r\n        message:\r\n          \"You are not authorized to finish this patrol. Only assigned inspectors can start the patrol.\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (!checklists || !results) {\r\n      res.status(400).json({ message: \"Invalid Data\" });\r\n      return;\r\n    }\r\n\r\n    if (status !== \"on_going\") {\r\n      res.status(400).json({ message: \"Cannot finish patrol.\" });\r\n      return;\r\n    }\r\n    const duration = calculateDuration(startTime);\r\n\r\n    await prisma.patrol.update({\r\n      where: {\r\n        id: patrolId,\r\n      },\r\n      data: {\r\n        status: \"completed\",\r\n        endTime: new Date(),\r\n        duration: duration,\r\n      },\r\n    });\r\n\r\n    const updatePatrol = await prisma.patrol.findFirst({\r\n      where: {\r\n        id: patrolId,\r\n      },\r\n      include: {\r\n        preset: {\r\n          select: {\r\n            id: true,\r\n            title: true,\r\n            description: true,\r\n          },\r\n        },\r\n        patrolChecklists: {\r\n          include: {\r\n            checklist: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                items: {\r\n                  include: {\r\n                    itemZones: {\r\n                      select: {\r\n                        zone: {\r\n                          select: {\r\n                            id: true,\r\n                            name: true,\r\n                            supervisor: {\r\n                              select: {\r\n                                id: true,\r\n                                profile: {\r\n                                  select: {\r\n                                    name: true,\r\n                                  },\r\n                                },\r\n                              },\r\n                            },\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            inspector: {\r\n              include: {\r\n                profile: {\r\n                  include: {\r\n                    image: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        results: {\r\n          include: {\r\n            defects: true,\r\n            comments: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    email: true,\r\n                    department: true,\r\n                    role: true,\r\n                    profile: {\r\n                      select: {\r\n                        name: true,\r\n                        image: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    for (const resultObj of results) {\r\n      const { id, status } = resultObj;\r\n\r\n      await prisma.patrolResult.update({\r\n        where: {\r\n          id: id,\r\n        },\r\n        data: {\r\n          status: status,\r\n        },\r\n      });\r\n    }\r\n\r\n    const notifiedInspectors = new Set<number>();\r\n    for (const checklistObj of checklists) {\r\n      const inspectorId = checklistObj.inspector.id;\r\n\r\n      if (!notifiedInspectors.has(inspectorId)) {\r\n        const message = `finish_patrol`;\r\n        await createNotification({\r\n          message: message,\r\n          type: \"information\" as NotificationType,\r\n          url: `/patrol/${patrolId}/detail`,\r\n          userId: inspectorId,\r\n        });\r\n        notifiedInspectors.add(inspectorId);\r\n      }\r\n    }\r\n\r\n    let result = updatePatrol;\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500);\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบ Patrol และข้อมูลที่เกี่ยวข้อง\r\n * Input:\r\n * - req.params.id: number (ID ของ Patrol ที่ต้องการลบ)\r\n * Output: JSON message ยืนยันการลบ Patrol และข้อมูลที่เกี่ยวข้องสำเร็จ\r\n**/\r\nexport async function removePatrol(req: Request, res: Response) {\r\n  try {\r\n    const patrolId = parseInt(req.params.id, 10);\r\n\r\n    await prisma.patrolChecklist.deleteMany({\r\n      where: {\r\n        patrolId: patrolId,\r\n      },\r\n    });\r\n\r\n    await prisma.patrolResult.deleteMany({\r\n      where: {\r\n        patrolId: patrolId,\r\n      },\r\n    });\r\n\r\n    await prisma.patrol.delete({\r\n      where: {\r\n        id: patrolId,\r\n      },\r\n    });\r\n\r\n    res.status(200).json({\r\n      message: \"Patrol and related records successfully deleted\",\r\n    });\r\n    return;\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Defect ทั้งหมดใน Patrol\r\n * Input:\r\n * - req.params.id: number (ID ของ Patrol)\r\n * - req.user: { userId: number } (บทบาทและ ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON array ข้อมูล Defect และข้อมูลที่เกี่ยวข้อง\r\n**/\r\nexport async function getAllPatrolDefects(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n\r\n    if (req.params.id) {\r\n      const patrolId = parseInt(req.params.id, 10);\r\n      const validPatrol = await prisma.patrol.findFirst({\r\n        where: {\r\n          id: patrolId,\r\n          patrolChecklists: {\r\n            some: {\r\n              userId: userId,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!validPatrol) {\r\n        res\r\n          .status(403)\r\n          .json({ message: \"You are not associated with this Patrol\" });\r\n        return;\r\n      }\r\n\r\n      const defects = await prisma.defect.findMany({\r\n        where: {\r\n          patrolResult: {\r\n            patrolId: patrolId,\r\n          },\r\n        },\r\n        include: {\r\n          patrolResult: {\r\n            select: {\r\n              zoneId: true,\r\n              itemZone: {\r\n                select: {\r\n                  zone: {\r\n                    select: {\r\n                      name: true,\r\n                      supervisor: {\r\n                        select: {\r\n                          id: true,\r\n                          profile: {\r\n                            include: {\r\n                              image: true\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            },\r\n          },\r\n          images: {\r\n            select: {\r\n              image: {\r\n                select: {\r\n                  id: true,\r\n                  path: true,\r\n                  user: {\r\n                    select: {\r\n                      id: true,\r\n                      email: true,\r\n                      role: true,\r\n                      department: true,\r\n                      createdAt: true\r\n                    }\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      let result = defects;\r\n      res.status(200).json(result);\r\n      return;\r\n    }\r\n    else {\r\n\r\n      const defects = await prisma.defect.findMany({\r\n        where: {\r\n          userId: userId,\r\n        },\r\n        include: {\r\n          patrolResult: {\r\n            select: {\r\n              patrol: {\r\n                select: {\r\n                  id: true,\r\n                  preset: {\r\n                    select: {\r\n                      title: true\r\n                    }\r\n                  }\r\n                }\r\n              },\r\n              zoneId: true,\r\n              itemZone: {\r\n                select: {\r\n                  zone: {\r\n                    select: {\r\n                      name: true,\r\n                      supervisor: {\r\n                        select: {\r\n                          id: true,\r\n                          profile: {\r\n                            include: {\r\n                              image: true\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n\r\n                    }\r\n                  }\r\n\r\n                }\r\n              }\r\n            },\r\n          },\r\n          images: {\r\n            select: {\r\n              image: {\r\n                select: {\r\n                  id: true,\r\n                  path: true,\r\n                  user: {\r\n                    select: {\r\n                      id: true,\r\n                      email: true,\r\n                      role: true,\r\n                      department: true,\r\n                      createdAt: true\r\n                    }\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      let result = defects;\r\n      res.status(200).json(result);\r\n      return;\r\n    }\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับเพิ่มความคิดเห็นใน Patrol\r\n * Input:\r\n * - req.params.id: number (ID ของ Patrol)\r\n * - req.body: { message: String, patrolResultId: number } (ข้อความความคิดเห็นและ ID ของผลลัพธ์)\r\n * - req.user: { userId: number } (บทบาทและ ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: JSON object ข้อมูลความคิดเห็นที่ถูกบันทึก\r\n**/\r\nexport async function commentPatrol(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const patrolId = parseInt(req.params.id, 10);\r\n    // รับข้อมูลจาก request body\r\n    const { message, patrolResultId, supervisorId } = req.body;\r\n\r\n    // ตรวจสอบว่าข้อมูลที่ส่งมาครบถ้วน\r\n    if (!message || !patrolResultId) {\r\n      res.status(400).json({ message: \"Bad Request: Missing required fields\" });\r\n      return;\r\n    }\r\n\r\n    // ตรวจสอบว่าผู้ใช้เกี่ยวข้องกับ Patrol นี้หรือไม่\r\n    const validPatrol = await prisma.patrol.findFirst({\r\n      where: {\r\n        id: patrolId,\r\n        patrolChecklists: {\r\n          some: {\r\n            userId: userId,\r\n          },\r\n        },\r\n      },\r\n    });\r\n    if (!validPatrol) {\r\n      res.status(403).json({ message: \"Patrol or checklist not found\" });\r\n      return;\r\n    }\r\n\r\n    // // รับ message เข้ามา และเชื่อมกับ PatrolResult\r\n    const newComment = await prisma.comment.create({\r\n      data: {\r\n        message: message,\r\n        timestamp: new Date(),\r\n        userId: userId,\r\n        patrolResultId: parseInt(patrolResultId, 10),\r\n      },\r\n    });\r\n\r\n    // const notification = `new_comment`;\r\n    // await createNotification({\r\n    //   message: notification,\r\n    //   type: \"request\" as NotificationType,\r\n    //   url: `/comment/${newComment.id}`,\r\n    //   userId: supervisorId,\r\n    // });\r\n\r\n    // ส่งข้อมูลคอมเมนต์พร้อมวันที่และเวลาที่บันทึกกลับไป\r\n    let result = newComment;\r\n    res.status(201).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500)\r\n    console.error(error);\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับตรวจสอบและอัปเดตสถานะ Patrol ที่เป็น \"pending\" ให้เป็น \"scheduled\"\r\n * Input:\r\n * - ไม่มี Input (ฟังก์ชันทำงานอัตโนมัติ)\r\n * Output: ไม่มี Output ที่ส่งกลับ แต่จะทำการอัปเดตสถานะในฐานข้อมูล\r\n**/\r\nexport async function checkAndUpdatePendingPatrols() {\r\n  try {\r\n    const patrols = await prisma.patrol.findMany({\r\n      where: {\r\n        status: \"pending\" as PatrolStatus,\r\n      },\r\n    });\r\n\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n\r\n    for (const patrol of patrols) {\r\n      const patrolDate = new Date(patrol.date);\r\n      patrolDate.setHours(0, 0, 0, 0);\r\n\r\n      if (patrolDate.getTime() === today.getTime()) {\r\n        try {\r\n          await prisma.patrol.update({\r\n            where: {\r\n              id: patrol.id,\r\n            },\r\n            data: {\r\n              status: \"scheduled\",\r\n            },\r\n          });\r\n        } catch (error) {\r\n          console.error(`Error updating patrol ${patrol.id}:`, error);\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching or updating patrols:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับกำหนดเวลาอัปเดตสถานะของ Patrol อัตโนมัติทุกเที่ยงคืน\r\n * Input:\r\n * - ไม่มี Input\r\n * Output: ไม่มี Output ที่ส่งกลับ (ฟังก์ชันทำงานเบื้องหลัง)\r\n**/\r\nexport function schedulePatrolStatusUpdate() {\r\n  const now = new Date();\r\n  const nextMidnight = new Date();\r\n  nextMidnight.setHours(24, 0, 0, 0);\r\n  const timeUntilMidnight = nextMidnight.getTime() - now.getTime();\r\n\r\n  setTimeout(() => {\r\n    checkAndUpdatePendingPatrols();\r\n    setInterval(checkAndUpdatePendingPatrols, 24 * 60 * 60 * 1000);\r\n  }, timeUntilMidnight);\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับคำนวณระยะเวลา (Duration) ของ Patrol\r\n * Input:\r\n * - startTime: String (เวลาเริ่มต้นของ Patrol ในรูปแบบ ISO 8601)\r\n * Output: String (ระยะเวลาในรูปแบบ \"xh ym zs\" เช่น \"2h 15m 30s\")\r\n**/\r\nconst calculateDuration = (startTime: string): string => {\r\n  // แปลง startTime เป็น Date object\r\n  const start = new Date(startTime);\r\n\r\n  // คำนวณเวลาปัจจุบัน\r\n  const end = new Date();\r\n\r\n  // คำนวณความแตกต่างในหน่วยมิลลิวินาที\r\n  const durationMs = end.getTime() - start.getTime();\r\n\r\n  // แปลงมิลลิวินาทีเป็นหน่วยชั่วโมง นาที และวินาที\r\n  const hours = Math.floor(durationMs / (1000 * 60 * 60));\r\n  const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));\r\n  const seconds = Math.floor((durationMs % (1000 * 60)) / 1000);\r\n\r\n  // แสดงผลในรูปแบบที่อ่านง่าย เช่น \"2h 15m 30s\"\r\n  return `${hours}h ${minutes}m ${seconds}s`;\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\preset-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":277,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":277,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":357,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":357,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":400,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":400,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":797,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":797,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from \"@Utils/database.js\";\r\nimport { Request, Response } from \"express\";\r\nimport { Checklist } from \"@prisma/client\";\r\n\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้าง Preset ใหม่\r\n * Input:\r\n * - req.body: {\r\n *     title: String,\r\n *     description: String,\r\n *     checklists: Array<{ checklist: { id: number } }>,\r\n *   } (ข้อมูลของ Preset ที่ต้องการสร้าง)\r\n * Output: JSON object { message: String, preset: Object } ยืนยันการสร้าง Preset สำเร็จ\r\n **/\r\nexport async function createPreset(req: Request, res: Response) {\r\n  try {\r\n    const { title, description, checklists } = req.body;\r\n    const userId = (req as any).user.userId;\r\n    const intChecklists: number[] = checklists.map(Number)\r\n\r\n    if (!title || !description || !Array.isArray(checklists) || !userId) {\r\n      res.status(400).json({ message: \"Missing required fields\" });\r\n      return;\r\n    }\r\n\r\n    const newPreset = await prisma.preset.create({\r\n      data: {\r\n        title,\r\n        description,\r\n        version: 1,\r\n        latest: true,\r\n        updatedAt: new Date(),\r\n        updatedBy: userId,\r\n      },\r\n    });\r\n\r\n    for (const checklistId of intChecklists) {\r\n      await prisma.presetChecklist.create({\r\n        data: {\r\n          presetId: newPreset.id,\r\n          checklistId,\r\n        },\r\n      });\r\n    }\r\n\r\n    res\r\n      .status(201)\r\n      .json({ message: \"Preset created successfully\", preset: newPreset });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: \"Internal server error\" });\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดต Preset\r\n * Input:\r\n * - req.params.id: number (ID ของ Preset ที่ต้องการอัปเดต)\r\n * - req.body: {\r\n *     title: String,\r\n *     description: String,\r\n *     checklists: Array<{ checklist: { id: number } }>,\r\n *     userId: number\r\n *   } (ข้อมูลของ Preset ที่ต้องการอัปเดต)\r\n * Output: JSON object { message: String, preset: Object } ยืนยันการอัปเดต Preset สำเร็จ\r\n **/\r\nexport async function updatePreset(req: Request, res: Response) {\r\n  try {\r\n    const { title, description, checklists } = req.body;\r\n    const userId = (req as any).user.userId;\r\n    const presetId = parseInt(req.params.id, 10);\r\n    const intChecklists: number[] = checklists.map(Number)\r\n\r\n    if (!presetId || !title || !description || !Array.isArray(checklists) || !userId) {\r\n      res.status(400).json({ message: \"Missing required fields\" });\r\n      return;\r\n    }\r\n\r\n    const currentPreset = await prisma.preset.findUnique({\r\n      where: { id: presetId },\r\n    });\r\n\r\n    if (!currentPreset) {\r\n      res.status(404).json({ message: \"Preset not found\" });\r\n      return;\r\n    }\r\n\r\n    await prisma.preset.update({\r\n      where: { id: presetId },\r\n      data: { latest: false },\r\n    });\r\n\r\n    const newPreset = await prisma.preset.create({\r\n      data: {\r\n        title: title,\r\n        description: description,\r\n        version: currentPreset.version + 1,\r\n        latest: true,\r\n        updatedAt: new Date(),\r\n        updatedBy: userId,\r\n      },\r\n    });\r\n\r\n    for (const checklistId of intChecklists) {\r\n      await prisma.presetChecklist.create({\r\n        data: {\r\n          presetId: newPreset.id,\r\n          checklistId: checklistId,\r\n        },\r\n      });\r\n    }\r\n    \r\n    res\r\n      .status(200)\r\n      .json({ message: \"Preset updated successfully\", preset: newPreset });\r\n  } catch (error) {\r\n    console.error(error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดต Checklist\r\n * Input:\r\n * - req.params.id: number (ID ของ Checklist ที่ต้องการอัปเดต)\r\n * - userId: number\r\n * - checklistId: number (ID ของ Checklist ที่ต้องการอัปเดต)\r\n * - title: string (ชื่อของ Checklist)\r\n * - items: Array (รายการไอเทมใน Checklist)</\r\n * Output: JSON object { message: String, checklist: Object } ยืนยันการอัปเดต Checklistสำเร็จ\r\n **/\r\nexport async function updateChecklist(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const checklistId = parseInt(req.params.id, 10);\r\n    const { title, items } = req.body;\r\n\r\n    // ตรวจสอบข้อมูล\r\n    if (!title || !items) {\r\n      res.status(400).json({ message: \"Missing required fields\" });\r\n      return;\r\n    }\r\n\r\n    const currentChecklist = await prisma.checklist.findUnique({\r\n      where: { id: checklistId },\r\n    });\r\n\r\n    if (!currentChecklist) {\r\n      res.status(404).json({ message: \"Checklist not found\" });\r\n      return;\r\n    }\r\n\r\n    if (currentChecklist.latest === true) {\r\n      const now = new Date();\r\n      const localTime = new Date(\r\n        now.getTime() - now.getTimezoneOffset() * 60000\r\n      ).toISOString();\r\n\r\n      if (title === currentChecklist.title) {\r\n        await prisma.checklist.update({\r\n          where: { id: checklistId },\r\n          data: { latest: false, updatedAt: localTime, updatedBy: userId },\r\n        });\r\n\r\n        // สร้าง Checklist ใหม่\r\n        const newChecklist = await prisma.checklist.create({\r\n          data: {\r\n            title: title,\r\n            version: currentChecklist.version + 1,\r\n            latest: true,\r\n            updatedAt: localTime, // อัปเดตใหม่ที่ใช้ในการตรวจสอบใหม่\r\n            updatedBy: userId, // ID ของผู้ใช้งานที่สร้าง\r\n          },\r\n        });\r\n        // สร้างไอเทมและเชื่อมโยงโซน\r\n        for (const item of items) {\r\n          const { name, type, zoneId } = item;\r\n\r\n          // สร้างไอเทมใหม่\r\n          const newItem = await prisma.item.create({\r\n            data: {\r\n              name: name,\r\n              type: type,\r\n              checklistId: newChecklist.id,\r\n            },\r\n          });\r\n\r\n          // เชื่อมโยงไอเทมกับโซนโดยใช้ Zone ID\r\n          for (const id of zoneId) {\r\n            const zone = await prisma.zone.findUnique({\r\n              where: { id: id },\r\n            });\r\n\r\n            if (!zone) {\r\n              res.status(404).json({ message: `Zone ID \"${id}\" not found` });\r\n              return;\r\n            }\r\n\r\n            // สร้าง itemZone\r\n            await prisma.itemZone.create({\r\n              data: {\r\n                itemId: newItem.id,\r\n                zoneId: zone.id,\r\n              },\r\n            });\r\n          }\r\n        }\r\n\r\n        res.status(201).json({\r\n          message: \"Checklist update successfully\",\r\n          checklists: newChecklist,\r\n        });\r\n      } else {\r\n        res\r\n          .status(500)\r\n          .json({ message: \"Title does not match the existing checklist\" }); //ชื่อมีการเปลี่ยนแปลง\r\n      }\r\n    } else {\r\n      res\r\n        .status(500)\r\n        .json({ message: \"Update restricted to the latest checklist only\" }); //ไม่ใช่ล่าสุด\r\n    }\r\n  } catch (error) {\r\n    console.error(error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Preset ตาม ID\r\n * Input:\r\n * - req.params.id: number (ID ของ Preset ที่ต้องการดึงข้อมูล)\r\n * Output: JSON object ข้อมูลของ Preset รวมถึงรายการ Checklist\r\n **/\r\nexport async function getPreset(req: Request, res: Response) {\r\n  try {\r\n    const presetId = parseInt(req.params.id, 10);\r\n    const preset = await prisma.preset.findUnique({\r\n      where: { id: presetId },\r\n      select: {\r\n        id: true,\r\n        title: true,\r\n        description: true,\r\n        presetChecklists: {\r\n          select: {\r\n            checklist: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                items: {\r\n                  include: {\r\n                    itemZones: {\r\n                      select: {\r\n                        zone: {\r\n                          select: {\r\n                            id: true,\r\n                            name: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!preset) {\r\n      res.status(404);\r\n      return;\r\n    }\r\n    let result = preset;\r\n    res.status(200).json(result);\r\n  } catch (error) {\r\n    res.status(500);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Preset ทั้งหมด\r\n * Input:\r\n * - req.query.latest: \"true\" | \"false\" (optional, ระบุเพื่อดึงเฉพาะ Preset ที่เป็นเวอร์ชันล่าสุด)\r\n * Output: JSON array ข้อมูลของ Preset ทั้งหมดรวมถึงรายการ Checklist และรายการ Zone\r\n **/\r\nexport async function getAllPresets(req: Request, res: Response) {\r\n  try {\r\n    let latest = true;\r\n    if (req.query.latest && req.query.latest === \"true\") {\r\n      latest = false;\r\n    }\r\n    const presets = await prisma.preset.findMany({\r\n      where: latest ? { latest: latest } : undefined,\r\n      select: {\r\n        id: true,\r\n        title: true,\r\n        description: true,\r\n        presetChecklists: {\r\n          select: {\r\n            checklist: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                items: {\r\n                  include: {\r\n                    itemZones: {\r\n                      select: {\r\n                        zone: {\r\n                          select: {\r\n                            id: true,\r\n                            name: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!presets.length) {\r\n      res.status(404);\r\n      return;\r\n    }\r\n\r\n    const result = presets.map((preset) => {\r\n      const zones = preset.presetChecklists.flatMap((checklist) =>\r\n        checklist.checklist.items.flatMap((item) =>\r\n          item.itemZones.map((itemZone) => ({\r\n            id: itemZone.zone.id,\r\n            name: itemZone.zone.name,\r\n          }))\r\n        )\r\n      );\r\n\r\n      // ใช้ Set เพื่อกรองค่าที่ซ้ำกัน\r\n      const uniqueZones = Array.from(\r\n        new Map(zones.map((zone) => [`${zone.id}-${zone.name}`, zone])).values()\r\n      );\r\n\r\n      return {\r\n        id: preset.id,\r\n        title: preset.title,\r\n        description: preset.description,\r\n        presetChecklists: preset.presetChecklists,\r\n        zones: uniqueZones,\r\n      };\r\n    });\r\n\r\n    res.status(200).json(result);\r\n  } catch (error) {\r\n    res.status(500);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบ Preset\r\n * Input:\r\n * - req.params.id: number (ID ของ Preset ที่ต้องการลบ)\r\n * Output: JSON object {  \"message\": \"Preset removed successfully\" } ยืนยันการลบ Preset สำเร็จ\r\n **/\r\nexport async function removePreset(req: Request, res: Response) {\r\n  try {\r\n    const presetId = parseInt(req.params.id, 10);\r\n    if (isNaN(presetId)) {\r\n      res.status(400).json({ message: \"Invalid Preset ID\" });\r\n      return;\r\n    }\r\n\r\n    // ตรวจสอบว่า Preset มีการใช้งานใน Patrol หรือไม่\r\n    const patrolCount = await prisma.patrol.count({\r\n      where: { presetId: presetId },\r\n    });\r\n\r\n    if (patrolCount > 0) {\r\n      res.status(400).json({\r\n        message:\r\n          \"Cannot delete Preset: Patrols are still linked to this Preset\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    // ลบข้อมูล PresetChecklist ที่เกี่ยวข้อง\r\n    await prisma.presetChecklist.deleteMany({\r\n      where: { presetId: presetId },\r\n    });\r\n\r\n    // ลบข้อมูล Preset\r\n    await prisma.preset.delete({\r\n      where: { id: presetId },\r\n    });\r\n\r\n    res.status(200).json({ message: \"Preset removed successfully\" });\r\n  } catch (error) {\r\n    res.status(500);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Checklist ตาม ID\r\n * Input:\r\n * - req.params.id: number (ID ของ Checklist ที่ต้องการดึงข้อมูล)\r\n * - req.query.supervisor: \"true\" | \"false\" (optional, ระบุเพื่อดึงข้อมูล Supervisor ที่เกี่ยวข้อง)\r\n * Output: JSON object ข้อมูลของ Checklist รวมถึงรายการ Item และ Zone\r\n **/\r\nexport async function getChecklist(req: Request, res: Response) {\r\n  try {\r\n    const checklistId = parseInt(req.params.id, 10);\r\n\r\n    // Check if the optional \"supervisor\" query parameter is included\r\n    const includeSupervisor = req.query.supervisor === \"true\";\r\n\r\n    // Fetch the checklist and its items from the database\r\n    const checklist = await prisma.checklist.findUnique({\r\n      where: { id: checklistId },\r\n      include: {\r\n        items: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            type: true,\r\n            checklistId: true,\r\n            itemZones: {\r\n              select: {\r\n                zone: {\r\n                  select: {\r\n                    id: true,\r\n                    name: true,\r\n                    supervisor: includeSupervisor\r\n                      ? {\r\n                        select: {\r\n                          id: true,\r\n                          role: true,\r\n                          profile: {\r\n                            select: {\r\n                              id: true,\r\n                              name: true,\r\n                              age: true,\r\n                              tel: true,\r\n                              address: true,\r\n                            },\r\n                          },\r\n                        },\r\n                      }\r\n                      : undefined,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    // Check if the checklist exists\r\n    if (!checklist) {\r\n      res.status(404).json({ message: \"Checklist not found\" });\r\n      return;\r\n    }\r\n\r\n    // Format the response to include the zone names for each item\r\n    const formattedChecklist = {\r\n      ...checklist,\r\n      items: checklist.items.map((item) => ({\r\n        ...item,\r\n      })),\r\n    };\r\n\r\n    res.status(200).json(formattedChecklist);\r\n  } catch (error) {\r\n    console.error(\"Error fetching checklist:\", error);\r\n    res.status(500).json({ message: \"Internal server error\" });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Checklist ทั้งหมด\r\n * Input:\r\n * - zones, startDate, endDate, search\r\n * Output: JSON array ข้อมูลของ Checklist รวมถึงการนับจำนวน Item แต่ละประเภท\r\n **/\r\nexport async function getAllChecklists(req: Request, res: Response) {\r\n  try {\r\n    // Fetch query parameters\r\n    const { zones, startDate, endDate, search } = req.query;\r\n\r\n    // Initialize where clause for filtering\r\n    const whereClause: any = {\r\n      latest: true,\r\n    };\r\n\r\n    // Filter by zones if provided\r\n    if (zones) {\r\n      whereClause.items = {\r\n        some: {\r\n          itemZones: {\r\n            some: {\r\n              zone: {\r\n                name: {\r\n                  in: (zones as string).split(\",\"), // Allow multiple zones separated by commas\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      };\r\n    }\r\n\r\n    // Filter by date range if provided\r\n    if (startDate || endDate) {\r\n      whereClause.updatedAt = {};\r\n      if (startDate) {\r\n        whereClause.updatedAt.gte = new Date(startDate as string); // greater than or equal to startDate\r\n      }\r\n      if (endDate) {\r\n        whereClause.updatedAt.lte = new Date(endDate as string); // less than or equal to endDate\r\n      }\r\n    }\r\n\r\n    // Search by title if provided (search only the checklist title)\r\n    if (search) {\r\n      whereClause.title = {\r\n        contains: search as string,\r\n       \r\n      };\r\n    }\r\n    \r\n    // Fetch filtered checklists with item and zone details\r\n    const checklists = await prisma.checklist.findMany({\r\n      where: whereClause,\r\n      include: {\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            username: true,\r\n            email: true,\r\n            profile: {\r\n              include: {\r\n                image: true\r\n              }\r\n            }\r\n          }\r\n        },\r\n        items: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            type: true, // Fetch item types\r\n            checklistId: true,\r\n            itemZones: {\r\n              select: {\r\n                zone: {\r\n                  select: {\r\n                    name: true,\r\n                    supervisor: {\r\n                      select: {\r\n                        profile: true,\r\n                      },\r\n                    }, // Fetch zone names\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n    \r\n    \r\n    if (!checklists.length) {\r\n      res.status(404).json({ message: \"No checklists found\" });\r\n      return;\r\n    }\r\n\r\n    // Fetch all versions to calculate version counts\r\n    const allChecklists = await prisma.checklist.findMany({\r\n      select: {\r\n        title: true,\r\n      },\r\n    });\r\n\r\n    // Calculate version counts for each title\r\n    const versionCounts = allChecklists.reduce((acc, checklist) => {\r\n      acc[checklist.title] = (acc[checklist.title] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n\r\n    // Fetch user information for the updatedBy field\r\n    const findUser = async (checklist: Checklist) => {\r\n      const findUser = await prisma.user.findUnique({\r\n        where: {\r\n          id: checklist.updatedBy,\r\n        },\r\n        select: {\r\n          username: true, // Include the username directly\r\n          profile: true,\r\n        },\r\n      });\r\n\r\n      const findImage = findUser?.profile?.imageId\r\n        ? await prisma.image.findUnique({\r\n            where: {\r\n              id: findUser.profile.imageId,\r\n            },\r\n          })\r\n        : null;\r\n\r\n      return {\r\n        username: findUser?.profile?.name || findUser?.username || \"Unknown User\",\r\n        profileImage: findImage?.path,\r\n      };\r\n    };\r\n\r\n    // Transform the result\r\n    const result = await Promise.all(\r\n      checklists.map(async (checklist) => {\r\n        const itemCounts = checklist.items.reduce(\r\n          (acc: Record<string, number>, item) => {\r\n            acc[item.type] = (acc[item.type] || 0) + 1;\r\n            return acc;\r\n          },\r\n          {}\r\n        );\r\n\r\n        const zoneNames = checklist.items\r\n          .flatMap((item) =>\r\n            item.itemZones.map((itemZone) => itemZone.zone.name)\r\n          )\r\n          .filter((name, index, self) => self.indexOf(name) === index); // Remove duplicates\r\n\r\n        const userdata = await findUser(checklist);\r\n\r\n        const items = checklist.items.filter((name, index, self) => self.indexOf(name) === index);\r\n\r\n        return {\r\n          id: checklist.id,\r\n          title: checklist.title,\r\n          version: checklist.version,\r\n          latest: checklist.latest,\r\n          updatedAt: checklist.updatedAt,\r\n          updateBy: checklist.updatedBy,\r\n          updateByUserName: userdata.username,\r\n          imagePath: userdata.profileImage || \"\",\r\n          itemCounts,\r\n          user: checklist.user,\r\n          zones: zoneNames,\r\n          versionCount: versionCounts[checklist.title] || 0, // Attach the version count\r\n          items: items,\r\n        };\r\n      })\r\n    );\r\n\r\n    res.status(200).json(result);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: \"Internal server error\" });\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้าง Checklist ใหม่\r\n * Input:\r\n * - req.body:\r\n *   - title: string (ชื่อของ Checklist)\r\n *   - items: Array (รายการของไอเทมใน Checklist)\r\n *     - name: string (ชื่อของไอเทม)\r\n *     - type: string (ประเภทของไอเทม เช่น safety, maintenance)\r\n *     - zoneId: Array<number> (Array ของ Zone ID ที่เชื่อมโยงกับไอเทมนั้น)\r\n * Output:\r\n * - JSON message ยืนยันการสร้าง Checklist สำเร็จ\r\n **/\r\nexport async function createChecklist(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n\r\n    // รับค่าจาก body\r\n    const { title, items } = req.body;\r\n\r\n    // ตรวจสอบข้อมูล\r\n    if (!title) {\r\n      res.status(400).json({ message: \"Missing required field title\" });\r\n      return;\r\n    }\r\n\r\n    if (!Array.isArray(items) || items.length === 0) {\r\n      res.status(400).json({ message: \"Items must not be empty\" });\r\n      return;\r\n    }\r\n\r\n    // ตรวจสอบว่า Checklist ที่มีชื่อเดียวกันมีอยู่แล้วหรือไม่\r\n    const existingChecklist = await prisma.checklist.findFirst({\r\n      where: { title },\r\n    });\r\n\r\n    if (existingChecklist) {\r\n      res\r\n        .status(400)\r\n        .json({ message: `Checklist with title \"${title}\" already exists` });\r\n      return;\r\n    }\r\n\r\n    const now = new Date();\r\n    const localTime = new Date(\r\n      now.getTime() - now.getTimezoneOffset() * 60000\r\n    ).toISOString();\r\n\r\n    // สร้าง Checklist ใหม่\r\n    const newChecklist = await prisma.checklist.create({\r\n      data: {\r\n        title: title,\r\n        version: 1,\r\n        latest: true,\r\n        updatedAt: localTime,\r\n        updatedBy: userId, // ID ของผู้ใช้งานที่สร้าง\r\n      },\r\n    });\r\n\r\n    // สร้างไอเทมและเชื่อมโยงโซน\r\n    for (const item of items) {\r\n      const { name, type, zoneId } = item;\r\n\r\n      // สร้างไอเทมใหม่\r\n      const newItem = await prisma.item.create({\r\n        data: {\r\n          name: name,\r\n          type: type,\r\n          checklistId: newChecklist.id,\r\n        },\r\n      });\r\n\r\n      // เชื่อมโยงไอเทมกับโซนโดยใช้ Zone ID\r\n      for (const id of zoneId) {\r\n        const zone = await prisma.zone.findUnique({\r\n          where: { id: id },\r\n        });\r\n\r\n        if (!zone) {\r\n          res.status(404).json({ message: `Zone ID \"${id}\" not found` });\r\n          return;\r\n        }\r\n\r\n        // สร้าง itemZone\r\n        await prisma.itemZone.create({\r\n          data: {\r\n            itemId: newItem.id,\r\n            zoneId: zone.id,\r\n          },\r\n        });\r\n      }\r\n    }\r\n\r\n    res.status(201).json({\r\n      message: \"Checklist created successfully\",\r\n      checklist: newChecklist,\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: \"Internal server error\" });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบ checklist (เปลี่ยนสถานะเป็น false)\r\n * Input: req.params.id: Int (ID ของ User ที่จะลบ)\r\n * Output: JSON message ยืนยันการลบ User สำเร็จ\r\n **/\r\nexport async function removeChecklist(req: Request, res: Response) {\r\n  try {\r\n    const id = parseInt(req.params.id, 10);\r\n    const checklist = await prisma.checklist.findUnique({\r\n      where: { id: id },\r\n    });\r\n\r\n    if (!checklist) {\r\n      res.status(404).json({ message: \"Checklist not found\" });\r\n      return;\r\n    }\r\n\r\n    await prisma.checklist.update({\r\n      where: { id: id },\r\n      data: {\r\n        latest: false,\r\n      },\r\n    });\r\n\r\n    res\r\n      .status(200)\r\n      .json({ message: \"Checklist has been deactivated successfully\" });\r\n    return;\r\n  } catch (error) {\r\n    res.status(500);\r\n    return;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\user-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":67,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":150,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":150,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":231,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":231,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":282,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":282,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":348,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":348,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":383,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":383,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from \"@Utils/database.js\";\r\nimport { Request, response, Response } from \"express\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport { faker } from \"@faker-js/faker\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport { Role } from \"@prisma/client\";\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้าง User ใหม่\r\n * Input: \r\n * - req.body: { username: String, email: String | null, password: String, role: String, department: String | null }\r\n * Output: JSON object ข้อมูล User ที่ถูกสร้าง\r\n**/\r\nexport async function createUser(req: Request, res: Response) {\r\n  try {\r\n    let { username, email, password, role, department } = req.body;\r\n    const hashPassword = await bcrypt.hash(password, 10);\r\n\r\n    const latestUser = await prisma.user.findFirst({\r\n      orderBy: {\r\n        id: \"desc\",\r\n      },\r\n    });\r\n\r\n    const nextId = (latestUser?.id ?? 0) + 1;\r\n    if (!username) {\r\n      const randomWord = faker.word.noun();\r\n      username = `${randomWord}${nextId}`;\r\n    }\r\n\r\n    const newUser = await prisma.user.create({\r\n      data: {\r\n        username: username,\r\n        email: email ?? null,\r\n        password: hashPassword,\r\n        role: role ?? \"inspector\",\r\n        department: department || null,\r\n      },\r\n    });\r\n\r\n    await prisma.profile.create({\r\n      data: {\r\n        userId: newUser.id,\r\n        name: null,\r\n        age: null,\r\n        tel: null,\r\n        address: null,\r\n      },\r\n    });\r\n    const user = await prisma.user.findUnique({\r\n      where: {\r\n        id: newUser.id,\r\n      },\r\n      include: {\r\n        profile: {\r\n          include: {\r\n            image: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    let result = user;\r\n    res.status(201).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดตข้อมูลส่วนตัวของ User\r\n * Input:\r\n * - (req as any).user.userId: number\r\n * - req.body: { name: String | null, age: number | null, tel: String | null, address: String | null }\r\n * - req.file?.filename: String (optional, path ของไฟล์รูปภาพ)\r\n * Output: JSON object ข้อมูล profile ที่ถูกอัปเดต หรือ error หากไม่พบ User\r\n**/\r\nexport async function updateProfile(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const imagePath = req.file?.filename || \"\"; // Use the filename created by multer\r\n\r\n    // Find the user in the database\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: userId },\r\n      include: {\r\n        profile: {\r\n          include: {\r\n            image: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(404).json({ error: \"User not found\" });\r\n      return\r\n    }\r\n\r\n    function getUploadsPath(): string {\r\n      const currentDir = process.cwd();\r\n      return path.join(currentDir, 'uploads'); // Adjust path as needed\r\n    }\r\n\r\n    const uploadsPath = getUploadsPath();\r\n\r\n    // Delete old image file if it exists\r\n    if (imagePath && user.profile?.image) {\r\n      const oldImagePath = path.join(uploadsPath, user.profile.image.path);\r\n      if (fs.existsSync(oldImagePath)) {\r\n        fs.unlinkSync(oldImagePath);\r\n      }\r\n    }\r\n\r\n    let image = null;\r\n    if (imagePath) {\r\n      // Upsert image (update if exists, create if not)\r\n      image = await prisma.image.upsert({\r\n        where: { id: user.profile?.image?.id || 0 },\r\n        update: {\r\n          path: imagePath,\r\n          updatedBy: userId,\r\n          profiles: {\r\n            connect: { id: user.profile?.id },\r\n          },\r\n        },\r\n        create: {\r\n          path: imagePath,\r\n          updatedBy: userId,\r\n          profiles: {\r\n            connect: { id: user.profile?.id },\r\n          },\r\n        },\r\n      });\r\n    }\r\n\r\n    // Update profile in the database\r\n    const updatedProfile = await prisma.profile.update({\r\n      where: { userId: userId },\r\n      data: {\r\n        imageId: image?.id || null, // Link the image if available\r\n      },\r\n    });\r\n\r\n    res.status(200).json(updatedProfile);\r\n    return\r\n  } catch (error) {\r\n    res.status(500).json({ error: \"Internal server error\" });\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล User \r\n * Input: \r\n * - req.query: { profile: \"true\" | \"false\", image: \"true\" | \"false\", password: \"true\" | \"false\" } (optional)\r\n * - req.params.id: number (optional, ถ้าไม่ระบุจะดึงข้อมูล User ที่ login อยู่)\r\n * Output: JSON object ข้อมูล User รวมถึง profile และ image หากมีการร้องขอ\r\n**/\r\nexport async function getUser(req: Request, res: Response) {\r\n  try {\r\n    const includeProfile = req.query.profile === \"true\";\r\n    const includeImage = req.query.image === \"true\";\r\n    const includePassword = req.query.password === \"true\";\r\n\r\n    const userId = (req as any).user.userId;\r\n    const userRole = (req as any).user.role;\r\n    const id = parseInt(req.params.id, 10);\r\n    let user = null;\r\n    if (id && userRole !== \"admin\" && userId !== id && includePassword) {\r\n      res\r\n        .status(403)\r\n        .json({ message: \"Access Denied: Only admins can access other users' data\" });\r\n      return\r\n    }\r\n    if (!id || id === userId) {\r\n      user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: {\r\n          id: true,\r\n          username: true,\r\n          email: true,\r\n          password: includePassword ? true : false,\r\n          role: true,\r\n          createdAt: true,\r\n          active: true,\r\n          profile: includeProfile\r\n            ? {\r\n              include: {\r\n                image: includeImage,\r\n              },\r\n            }\r\n            : undefined,\r\n          zone: true\r\n        },\r\n      });\r\n    } else {\r\n      user = await prisma.user.findUnique({\r\n        where: { id: id },\r\n        select: {\r\n          id: true,\r\n          username: true,\r\n          email: true,\r\n          password: includePassword ? true : false,\r\n          role: true,\r\n          createdAt: true,\r\n          active: true,\r\n          profile: includeProfile\r\n            ? {\r\n              include: {\r\n                image: includeImage,\r\n              },\r\n            }\r\n            : undefined,\r\n          zone: true\r\n        },\r\n      });\r\n    }\r\n\r\n    if (!user) {\r\n      res.status(404);\r\n      return;\r\n    }\r\n\r\n    let result = user;\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล User ทั้งหมด\r\n * Input: \r\n * - req.query: { profile: \"true\" | \"false\", image: \"true\" | \"false\", \"role\": \"admin\" | \"inspector\" | \"supervisor\" } (optional)\r\n * Output: JSON array ข้อมูล User รวมถึง profile และ image หากมีการร้องขอ\r\n**/\r\nexport async function getAllUsers(req: Request, res: Response) {\r\n  try {\r\n    const includeProfile = req.query.profile === \"true\";\r\n    const includeImage = req.query.image === \"true\";\r\n    const includeUsername = req.query.user === \"true\";\r\n    const role = req.query.role as string;\r\n\r\n    const validRoles = [\"admin\", \"inspector\", \"supervisor\"]; // Adjust based on your Role enum\r\n    const roleFilter = validRoles.includes(role) ? (role as Role) : undefined;\r\n\r\n    const allUsers = await prisma.user.findMany({\r\n      where: {\r\n        role: roleFilter\r\n      },\r\n      select: {\r\n        id: true,\r\n        username: includeUsername,\r\n        email: true,\r\n        role: true,\r\n        createdAt: true,\r\n        active: true,\r\n        profile: includeProfile\r\n          ? {\r\n            include: {\r\n              image: includeImage,\r\n            },\r\n          }\r\n          : undefined,\r\n      },\r\n    });\r\n\r\n    if (allUsers) {\r\n      let result = allUsers;\r\n      res.status(200).json(result);\r\n      return;\r\n    } else {\r\n      response.status(404);\r\n      return;\r\n    }\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดตข้อมูล User\r\n * Input: \r\n * - req.params.id: number (ID ของ User ที่จะอัปเดต)\r\n * - req.body: { username: String, email: String | null, password: String, role: String, department: String | null }\r\n * Output: JSON object ข้อมูล User หลังการอัปเดต\r\n * Note: admin เท่านั้นที่สามารถอัปเดต role และ username ได้\r\n**/\r\nexport async function updateUser(req: Request, res: Response) {\r\n  try {\r\n    const loggedInUserId = (req as any).user.userId;\r\n    const loggedInUserRole = (req as any).user.role;\r\n    const id = parseInt(req.params.id, 10);\r\n    const { username, name, email, tel, address, password, role, department } = req.body;\r\n    const age = parseInt(req.body.age)\r\n    const updateUser: any = {};\r\n    const updateProfile: any = {};\r\n    if (username !== undefined) updateUser.username = username;\r\n    if (email !== undefined) updateUser.email = email;\r\n    if (password !== undefined) updateUser.password = password;\r\n    if (role !== undefined) updateUser.role = role;\r\n    if (department !== undefined) updateUser.department = department;\r\n    if (name !== undefined) updateProfile.name = name;\r\n    if (age !== undefined) updateProfile.age = age;\r\n    if (tel !== undefined) updateProfile.tel = tel;\r\n    if (address !== undefined) updateProfile.address = address;\r\n\r\n    // ตรวจสอบว่าผู้ใช้ที่ล็อกอินอยู่เป็นเจ้าของบัญชีที่กำลังถูกอัปเดต หรือเป็น admin\r\n    if (loggedInUserId !== id && loggedInUserRole !== \"admin\") {\r\n      res.status(403).json({\r\n        message:\r\n          \"Access Denied: You must be the owner of this account or an admin\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    // อัปเดตข้อมูลผู้ใช้\r\n    await prisma.user.update({\r\n      where: { id: id },\r\n      data: updateUser,\r\n    });\r\n\r\n    await prisma.profile.update({\r\n      where: { id: id },\r\n      data: updateProfile,\r\n    })\r\n\r\n    const result = await prisma.user.findUnique({\r\n      where: { id: id },\r\n      include: {\r\n        profile: {\r\n          include: {\r\n            image: true\r\n          }\r\n        },\r\n      },\r\n    });;\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบ User (เปลี่ยนสถานะเป็น inactive)\r\n * Input: req.params.id: Int (ID ของ User ที่จะลบ)\r\n * Output: JSON message ยืนยันการลบ User สำเร็จ\r\n**/\r\nexport async function removeUser(req: Request, res: Response) {\r\n  try {\r\n    const id = parseInt(req.params.id, 10);\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: id },\r\n      include: { profile: true, zone: true },\r\n    });\r\n\r\n\r\n    if (!user) {\r\n      res.status(404).json({ message: \"User not found\" });\r\n      return;\r\n    }\r\n\r\n    await prisma.user.update({\r\n      where: { id: id },\r\n      data: {\r\n        active: false,\r\n      },\r\n    });\r\n\r\n    res.status(200).json({ message: \"User has been deactivated successfully\" });\r\n    return;\r\n  } catch (error) {\r\n    res.status(500)\r\n    return;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\util-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":154,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":154,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":217,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":217,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":237,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":237,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":266,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":266,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import bcrypt from \"bcryptjs\";\r\nimport prisma from \"@Utils/database.js\";\r\nimport { NextFunction, Request, Response } from \"express\";\r\nimport jwt, { JwtPayload } from 'jsonwebtoken';\r\nimport multer from 'multer';\r\nimport { getIOInstance } from '@Utils/socket.js';\r\nimport nodemailer from 'nodemailer';\r\n\r\ndeclare global {\r\n  namespace Express {\r\n    interface Request {\r\n      user?: string | JwtPayload;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับ login เข้าสู่ระบบ\r\n * Input: \r\n * - req.body: { username: String, password: String, rememberMe: Boolean}\r\n * Output: JSON message ยืนยันการ login สำเร็จ\r\n**/\r\nexport async function login(req: Request, res: Response) {\r\n  const { username, password, rememberMe } = req.body;\r\n  try {\r\n    // Find the user by username\r\n    const user = await prisma.user.findUnique({\r\n      where: { username: username },\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(401).json({ message: \"Invalid username\" });\r\n      return;\r\n    }\r\n\r\n    // Compare the provided password with the hashed password in the database\r\n    const passwordMatch = await bcrypt.compare(password, user.password);\r\n\r\n    if (!passwordMatch) {\r\n      res.status(401).json({ message: \"Invalid password\" });\r\n      return;\r\n    }\r\n\r\n    // Generate a JWT token and set it as a cookie with an expiration time\r\n    const jwtSecret = process.env.JWT_SECRET || \"defaultSecretKey\";\r\n    const maxAge = rememberMe ? 30 * 24 * 60 * 60 * 1000 : 1 * 60 * 60 * 1000;\r\n    const iat = Math.floor(Date.now() / 1000);\r\n    const exp = iat + maxAge / 1000;\r\n    const token = jwt.sign({ userId: user.id, role: user.role, iat, exp }, jwtSecret);\r\n\r\n    res.cookie(\"authToken\", token, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === \"production\" ? true : false,\r\n      sameSite: process.env.NODE_ENV === \"production\" ? 'none' : 'lax',\r\n      maxAge: maxAge,\r\n    });\r\n\r\n    res.status(200).json({ message: \"Login Success\", token });\r\n    return\r\n  } catch (error) {\r\n    res.status(500).json({ message: \"Internal Server Error\", error });\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับ logout ออกจากระบบ\r\n * Input: \r\n * - req.cookies.authToken: String (Token ของผู้ใช้งานที่ใช้สำหรับการยืนยันตัวตน) \r\n * Output: JSON message ยืนยันการ logout สำเร็จ\r\n**/\r\nexport async function logout(req: Request, res: Response) {\r\n  try {\r\n    // Clear the cookie named \"authToken\"\r\n    res.clearCookie(\"authToken\", {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === \"production\" ? true : false,\r\n      sameSite: process.env.NODE_ENV === \"production\" ? 'none' : 'lax'\r\n    });\r\n    res.status(200).json({ message: \"Logout successful\" });\r\n    return\r\n  } catch (error) {\r\n    res.status(500).json({ message: \"Internal Server Error\", error });\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับตรวจสอบการยืนยันตัวตนของผู้ใช้งาน (Authentication)\r\n * Input: \r\n * - req.cookies.authToken: String (Token ของผู้ใช้งานที่ใช้สำหรับการยืนยันตัวตน) \r\n * Output: \r\n * - ถ้า Token ถูกต้อง: ส่งต่อการทำงานไปยังฟังก์ชันถัดไป (next middleware)\r\n * - ถ้า TOken ไม่ถูกต้อง: JSON message แจ้งเตือนข้อผิดพลาด เช่น \"Access Denied\" หรือ \"Invalid Token\"\r\n**/\r\nexport function authenticateUser(req: Request, res: Response, next: NextFunction) {\r\n  const token = req.cookies.authToken;\r\n\r\n  if (!token) {\r\n    res.status(401).json({ message: \"Access Denied, No Token Provided\" });\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const jwtSecret = process.env.JWT_SECRET || \"defaultSecretKey\";\r\n    const decoded = jwt.verify(token, jwtSecret);\r\n    req.user = decoded;\r\n    next();\r\n  } catch (error) {\r\n    res.status(400).json({ message: \"Invalid Token\", error })\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัพโหลดรูปภาพโดยใช้ multer\r\n * Input: \r\n * - req.file: Object (ไฟล์รูปภาพที่อัปโหลด โดย multer จะทำการจัดการและเพิ่มลงใน `uploads/`)\r\n * - req.body: Object (ข้อมูลเพิ่มเติมที่แนบมากับการอัปโหลดรูปภาพ)\r\n * Output: \r\n * - ไฟล์ที่อัปโหลดจะถูกจัดเก็บในโฟลเดอร์ `uploads/` พร้อมกับชื่อไฟล์ที่ไม่ซ้ำกัน\r\n * - req.file: Object (รายละเอียดของไฟล์ที่ถูกอัปโหลด เช่น ชื่อไฟล์, ขนาดไฟล์, และประเภทของไฟล์)\r\n**/\r\nconst storage = multer.diskStorage({\r\n  destination: function (req, file, callback) {\r\n    callback(null, 'uploads/'); // กำหนดโฟลเดอร์สำหรับเก็บไฟล์ที่อัปโหลด\r\n  },\r\n  filename: function (req, file, callback) {\r\n    const uniqueSuffix = Date.now() + '-' + file.originalname; // ตั้งชื่อไฟล์ใหม่ให้ไม่ซ้ำกัน\r\n    callback(null, uniqueSuffix);  // บันทึกชื่อไฟล์\r\n  }\r\n});\r\n\r\n// Export the multer upload middleware\r\nexport const upload = multer({ storage: storage });\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูลการแจ้งเตือน\r\n * Input: \r\n * - (req as any).user.userId : Int (Id ของผู้ใช้ที่กำลังล็อคอิน)\r\n * Output: JSON message ของ notification  \r\n**/\r\nexport async function getNotifications(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n\r\n    const notifications = await prisma.notification.findMany({\r\n      where: { userId: userId },\r\n      orderBy: { timestamp: 'desc' },\r\n    });\r\n    let result = notifications;\r\n\r\n    res.status(200).json(result);\r\n  } catch (error) {\r\n    res.status(500)\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้างการแจ้งเตือน\r\n * Input: \r\n * - req.body: { message: string, type: NotificationType, url: String | Null, userId: Int }\r\n * Output: JSON object ของ notification ที่ถูกสร้าง รวมถึงข้อมูลที่เกี่ยวข้อง \r\n**/\r\nexport async function createNotification({ message, type, url, userId }: any) {\r\n  try {\r\n    const notification = await prisma.notification.create({\r\n      data: {\r\n        message,\r\n        timestamp: new Date(),\r\n        type,\r\n        url,\r\n        read: false,\r\n        userId,\r\n      },\r\n    });\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: userId },\r\n      select: { email: true },\r\n    });\r\n\r\n    // Send an email notification if the user's email exists\r\n    if (user?.email) {\r\n      const emailSubject = 'New Notification';\r\n      const emailMessage = `You have a new notification: ${message}. Check it here: ${url}`;\r\n\r\n      await sendEmail(user.email, emailSubject, emailMessage);\r\n    }\r\n\r\n    let result = notification;\r\n\r\n    // Emit an event to notify the client in real-time\r\n    const io = getIOInstance();\r\n    io.to(userId).emit('new_notification', result);\r\n\r\n    return notification;\r\n  } catch (error) {\r\n    console.error(\"Error creating notification\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดตสถานะการแจ้งเตือนให้เป็น \"อ่านแล้ว\"\r\n * Input: \r\n * - req.params: { id: int } (ID ของการแจ้งเตือนที่ต้องการอัปเดต)\r\n * Output: JSON object ของการแจ้งเตือนที่ถูกอัปเดต \r\n**/\r\nexport async function updateNotification(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n    const notification = await prisma.notification.update({\r\n      where: { id: parseInt(id, 10) },\r\n      data: { read: true },\r\n    });\r\n    res.status(200).json(notification);\r\n  } catch (error) {\r\n    res.status(500)\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับเปลี่ยนสถานะการแจ้งเตือนทั้งหมดของผู้ใช้ให้เป็น \"อ่านแล้ว\"\r\n * Input: \r\n * - req.user.userId: int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: \r\n * - JSON message ยืนยันการเปลี่ยนสถานะการแจ้งเตือนสำเร็จ\r\n**/\r\nexport async function markAllAsRead(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    await prisma.notification.updateMany({\r\n      where: { userId: userId, read: false },\r\n      data: { read: true },\r\n    });\r\n    res.status(200).json({ message: \"All notifications marked as read\" });\r\n  } catch (error) {\r\n    res.status(500)\r\n  }\r\n}\r\n\r\n// Function to mark a specific notification as read by checking its ID\r\nexport async function markAsRead(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Check if the notification exists and is unread\r\n    const notification = await prisma.notification.findFirst({\r\n      where: {\r\n        id: parseInt(id),\r\n        read: false,\r\n      },\r\n    });\r\n\r\n    if (!notification) {\r\n      return res.status(404).json({ message: \"No unread notifications found\" });\r\n    }\r\n\r\n    // Update the notification to mark it as read\r\n    await prisma.notification.update({\r\n      where: { id: parseInt(id) },\r\n      data: { read: true },\r\n    });\r\n\r\n    res.status(200).json({ message: \"Notification marked as read\" });\r\n  } catch (error) {\r\n    res.status(500)\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบการแจ้งเตือนที่มีอายุเกิน 7 วัน\r\n * Input: \r\n * - ไม่มี Input\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะลบการแจ้งเตือนเก่าจากฐานข้อมูล\r\n**/\r\nexport async function removeOldNotifications() {\r\n  try {\r\n    const sevenDaysAgo = new Date();\r\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\r\n\r\n    await prisma.notification.deleteMany({\r\n      where: {\r\n        timestamp: {\r\n          lt: sevenDaysAgo,\r\n        },\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error deleting old notifications:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบการแจ้งเตือนที่ต้องการ\r\n * Input: \r\n * - req.param = id\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะลบการแจ้งเตือนออกจากฐานข้อมูล\r\n**/\r\nexport async function removeNotification(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n    await prisma.notification.delete({\r\n      where: {\r\n        id: parseInt(id),\r\n      },\r\n    });\r\n    res.status(200)\r\n    return\r\n  } catch (error) {\r\n    console.error(\"Error deleting notification:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบการแจ้งเตือนที่ต้องการ\r\n * Input: \r\n * - req.user: { userId: number } (บทบาทและ ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะลบการแจ้งเตือนทั้งหมดของผู้ใช้ออกจากฐานข้อมูล\r\n**/\r\nexport async function removeAllNotifications(req: Request, res: Response) {\r\n  const userId = (req as any).user.userId;\r\n  try {\r\n    await prisma.notification.deleteMany({\r\n      where: {\r\n        userId: userId,\r\n      },\r\n    });\r\n    res.status(200)\r\n    return\r\n  } catch (error) {\r\n    console.error(\"Error deleting notification:\", error);\r\n  }\r\n}\r\n\r\n// Nodemailer transporter for sending emails\r\nconst transporter = nodemailer.createTransport({\r\n  service: 'gmail',\r\n  auth: {\r\n    user: process.env.EMAIL_USER,\r\n    pass: process.env.EMAIL_PASSWORD,\r\n  },\r\n});\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับส่งอีเมลโดยใช้ nodemailer\r\n * Input: \r\n * - email: String (อีเมลผู้รับ)\r\n * - subject: String (หัวข้อของอีเมล)\r\n * - message: String (ข้อความในเนื้อหาอีเมล)\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะทำการส่งอีเมล\r\n**/\r\nexport async function sendEmail(email: string, subject: string, message: string) {\r\n  try {\r\n    await transporter.sendMail({\r\n      from: process.env.EMAIL_USER,\r\n      to: email,\r\n      subject: subject,\r\n      text: message,\r\n    });\r\n  } catch (error) {\r\n    console.error('Error sending email:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับตรวจสอบสิทธิ์การเข้าถึง\r\n * Input: \r\n * - allowedRoles: string[] (role ที่อณุญาติให้เข้าถึงข้อมูล)\r\n * Output: \r\n * - ทำ Function  ต่อไป\r\n**/\r\nexport function authorzied(allowedRoles: string[]) {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    const userRole = (req as any).user.role;\r\n\r\n    if (!allowedRoles.includes(userRole)) {\r\n      res.status(403).json({ message: `Access Denied: Required roles are ${allowedRoles.join(\", \")}` });\r\n      return;\r\n    }\r\n    next();\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\defect-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\location-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\patrol-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\preset-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\user-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\util-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\cors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\checklists.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\images.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\item-zones.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\locations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\patrol-checklists.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\patrols.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\preset-checklist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\presets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\profiles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\users.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\zones.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\socket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\_mocks_\\defect.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\_mocks_\\location.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\_mocks_\\patrol.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\_mocks_\\prisma.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\_mocks_\\util.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\defect.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\location.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\patrol.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\singleton.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\tests\\util.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createNotification' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createNotificationMock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'notificationMock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":83},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getIOInstance' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { authenticateUser, authorzied, createNotification, getNotifications, login, logout, markAllAsRead, removeAllNotifications, removeOldNotifications, updateNotification } from \"@Controllers/util-controller.js\";\r\nimport { prismaMock } from \"./_mocks_/prisma.mock\";\r\nimport { allNotificationMock, createNotificationMock, decodeMock, notificationMock, updateNotificationMock, userMock } from \"./_mocks_/util.mock\";\r\nimport { getIOInstance } from \"@Utils/socket.js\";\r\n\r\n// Mock Response object\r\nconst mockResponse = (overrides: Partial<Response> = {}) => {\r\n  const res: Partial<Response> = {\r\n    status: jest.fn().mockReturnThis(),\r\n    json: jest.fn().mockReturnThis(),\r\n    cookie: jest.fn().mockReturnThis(),\r\n    clearCookie: jest.fn().mockReturnThis(),\r\n    ...overrides,\r\n  };\r\n  return res as Response;\r\n};\r\n\r\n// Mock Request object\r\nconst mockRequest = (query: any, params: any, body: any, user: any, cookies: any) => {\r\n  return {\r\n    query,\r\n    params,\r\n    body,\r\n    user,\r\n    cookies,\r\n  } as unknown as Request;\r\n};\r\n\r\njest.mock('bcryptjs', () => ({\r\n  compare: jest.fn(),\r\n}));\r\n\r\njest.mock('jsonwebtoken', () => ({\r\n  sign: jest.fn(),\r\n  verify: jest.fn(),\r\n}));\r\n\r\ndescribe('login', () => {\r\n  test('ควรเข้าสู่ระบบได้สำเร็จ', async () => {\r\n    prismaMock.user.findUnique.mockResolvedValue(userMock);\r\n    (bcrypt.compare as jest.Mock).mockResolvedValue(true);\r\n    (jwt.sign as jest.Mock).mockReturnValue(\"mockToken\");\r\n\r\n    (global.Date.now as jest.Mock) = jest.fn(() => 1702310400000);\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {\r\n        username: \"testuser\",\r\n        password: \"testpassword\",\r\n        rememberMe: true,\r\n      },\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await login(req, res);\r\n    expect(bcrypt.compare).toHaveBeenCalledWith(\"testpassword\", \"hashedPassword\");\r\n\r\n    expect(jwt.sign).toHaveBeenCalledWith(\r\n      {\r\n        userId: 1,\r\n        role: \"inspector\",\r\n        iat: 1702310400,\r\n        exp: expect.any(Number),\r\n      },\r\n      expect.any(String)\r\n    );\r\n\r\n    expect(res.cookie).toHaveBeenCalledWith(\"authToken\", \"mockToken\", expect.any(Object));\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith({ message: \"Login Success\", token: \"mockToken\" });\r\n  });\r\n});\r\n\r\ndescribe('logout', () => {\r\n  test('ควรออกจากระบบได้สำเร็จ', async () => {\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      { role: \"inspector\", userId: 3 },\r\n      { authToken: \"mockToken\" });\r\n\r\n    const res = mockResponse();\r\n\r\n    await logout(req, res);\r\n\r\n    expect(res.clearCookie).toHaveBeenCalledWith(\"authToken\", {\r\n      httpOnly: true,\r\n      secure: false,\r\n      sameSite: 'lax',\r\n    });\r\n\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith({ message: \"Logout successful\" });\r\n  });\r\n});\r\n\r\ndescribe('authenticateUser', () => {\r\n  test('ควรยืนยันตัวตนผู้ใช้งานได้สำเร็จ', async () => {\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      { role: \"inspector\", userId: 3 },\r\n      { authToken: \"mockToken\" });\r\n\r\n    const res = mockResponse();\r\n    const next = jest.fn();\r\n    (jwt.verify as jest.Mock).mockReturnValue(decodeMock);\r\n\r\n    authenticateUser(req, res, next);\r\n    expect(req.user).toEqual(decodeMock);\r\n    expect(next).toHaveBeenCalled();\r\n  });\r\n});\r\n\r\ndescribe('getNotifications', () => {\r\n  test('ควรดึงข้อมูล Notification ได้ถูกต้อง', async () => {\r\n    prismaMock.notification.findMany.mockResolvedValueOnce(allNotificationMock);\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await getNotifications(req, res);\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith(allNotificationMock);\r\n  });\r\n});\r\n\r\n\r\njest.mock('@Utils/socket.js', () => ({\r\n  getIOInstance: jest.fn().mockReturnValue({\r\n    to: jest.fn().mockReturnThis(),\r\n    emit: jest.fn(),\r\n  }),\r\n}));\r\n\r\n// describe('createNotification', () => {\r\n//   test('ควรสร้าง Notification และเรียก emit ผ่าน IOInstance ได้สำเร็จ', async () => {\r\n//     prismaMock.notification.create.mockResolvedValue(notificationMock);\r\n//     prismaMock.user.findUnique.mockResolvedValue(createNotificationMock);\r\n\r\n//     const message = \"notification test\";\r\n//     const type = \"request\";\r\n//     const url = \"/patrol/3\";\r\n//     const userId = 3;\r\n\r\n//     const data = { message, type, url, userId };\r\n//     console.log('Test input data:', data);\r\n\r\n//     await createNotification(data);\r\n//     console.log('Prisma Mock Calls:', prismaMock.notification.create.mock.calls);\r\n\r\n//     expect(prismaMock.notification.create).toHaveBeenCalledTimes(1);\r\n\r\n//     // expect(prismaMock.notification.create).toHaveBeenCalledWith(notificationMock);\r\n//     expect(getIOInstance).toHaveBeenCalled();\r\n//     expect(getIOInstance().to).toHaveBeenCalledWith(userId);\r\n//     expect(getIOInstance().emit).toHaveBeenCalledWith('new_notification', notificationMock);\r\n//   });\r\n// });\r\n\r\ndescribe('updateNotification', () => {\r\n  test('ควรเปลี่ยนสถานะ Notification เป็น \"อ่านแล้ว\"', async () => {\r\n    prismaMock.notification.update.mockResolvedValueOnce(updateNotificationMock);\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      { id: 1 },\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await updateNotification(req, res);\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith(updateNotificationMock);\r\n  });\r\n});\r\n\r\ndescribe('markAllAsRead', () => {\r\n  test('ควรเปลี่ยนสถานะ Notification ทั้งหมดเป็น \"อ่านแล้ว\"', async () => {\r\n    prismaMock.notification.updateMany.mockResolvedValueOnce({\r\n      count: 2,\r\n    });\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      { id: 1 },\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await markAllAsRead(req, res);\r\n    expect(prismaMock.notification.updateMany).toHaveBeenCalledWith({\r\n      where: { userId: 3, read: false },\r\n      data: { read: true },\r\n    });\r\n\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith({ message: \"All notifications marked as read\" });\r\n  });\r\n});\r\n\r\ndescribe('removeOldNotifications', () => {\r\n  beforeAll(() => {\r\n    jest.useFakeTimers().setSystemTime(new Date(\"2025-01-12T15:09:36.718Z\"));\r\n  });\r\n\r\n  afterAll(() => {\r\n    jest.useRealTimers();\r\n  });\r\n  test('ควรลบ Notification ที่เก่ากว่า 7 วัน', async () => {\r\n    prismaMock.notification.deleteMany.mockResolvedValueOnce({\r\n      count: 2,\r\n    });\r\n\r\n\r\n    const sevenDaysAgo = new Date(\"2025-01-12T15:09:36.718Z\");\r\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\r\n\r\n    await removeOldNotifications();\r\n    expect(prismaMock.notification.deleteMany).toHaveBeenCalledWith({\r\n      where: {\r\n        timestamp: {\r\n          lt: sevenDaysAgo,\r\n        },\r\n      },\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('removeAllNotifications', () => {\r\n  test('ควรลบ Notification ทั้งหมดของผู้ใช้', async () => {\r\n    prismaMock.notification.deleteMany.mockResolvedValueOnce({\r\n      count: 2,\r\n    })\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await removeAllNotifications(req, res);\r\n    expect(prismaMock.notification.deleteMany).toHaveBeenCalledWith({\r\n      where: {\r\n        userId: 3,\r\n      },\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('authorzied', () => {\r\n  test('ควรอนุญาตให้ผู้ใช้ที่มีบทบาทใน allowedRoles ผ่านได้', async () => {\r\n    const allowedRoles = [\"admin\", \"inspector\"];\r\n    const middleware = authorzied(allowedRoles);\r\n\r\n    const req = mockRequest({}, {}, {}, { role: \"inspector\", userId: 3 }, {});\r\n    const res = mockResponse();\r\n    const next = jest.fn();\r\n\r\n    middleware(req, res, next);\r\n\r\n    expect(next).toHaveBeenCalled();\r\n    expect(res.status).not.toHaveBeenCalled();\r\n  });\r\n});\r\n","usedDeprecatedRules":[]}]