[{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\eslint-report.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\jest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\dashboard-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'prevPercent' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":595,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":595,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from \"@Utils/database.js\";\r\nimport { Request, Response } from \"express\";\r\nimport { calculateTrend } from \"@Controllers/util-controller.js\";\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล HeatMap ของ Defects ในแต่ละ Zone\r\n * Input:\r\n * - req.query: { startDate: string, endDate: string } (ตัวกรองวันที่)\r\n * Output: JSON object ข้อมูล HeatMap โดยแสดงจำนวน Defects ในแต่ละ Zone\r\n **/\r\nexport async function getHeatMap(req: Request, res: Response) {\r\n  try {\r\n    const { startDate, endDate } = req.query;\r\n    // สร้างตัวกรองสำหรับวันที่ ถ้ามี startDate และ endDate\r\n    const dateFilter: any = {};\r\n    if (startDate || endDate) {\r\n      dateFilter.startTime = {\r\n        ...(startDate && { gte: new Date(startDate as string) }),\r\n        ...(endDate && { lte: new Date(endDate as string) }),\r\n      };\r\n    }\r\n    const allZones = await prisma.zone.findMany({\r\n      include: {\r\n        itemZones: {\r\n          include: {\r\n            results: {\r\n              select: {\r\n                defects: {\r\n                  where: dateFilter,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!allZones) {\r\n      res.status(404).json({ message: \"Zones not found\" });\r\n      return;\r\n    }\r\n\r\n    // คำนวณ heatMap\r\n    const heatMap = allZones.map((zone) => {\r\n      let defectCount = 0;\r\n\r\n      // วนลูปผ่านทุกๆ itemZone ของ zone\r\n      zone.itemZones.forEach((itemZone) => {\r\n        itemZone.results.forEach((result) => {\r\n          defectCount += result.defects.length; // เพิ่มจำนวน defects ที่ตรงเงื่อนไข\r\n        });\r\n      });\r\n\r\n      // คืนค่าข้อมูลที่มี id, name และ defects\r\n      return {\r\n        id: zone.id,\r\n        name: zone.name,\r\n        defects: defectCount,\r\n      };\r\n    });\r\n\r\n    let result = heatMap;\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Defect Category และคำนวณแนวโน้มการเกิด Defects\r\n * Input:\r\n * - req.query: { startDate: string, endDate: string, patrolId: string, zoneId: string } (ตัวกรองสำหรับวันที่, patrolId, zoneId)\r\n * Output: JSON object ข้อมูล Defect Category พร้อมด้วยแนวโน้มการเกิด Defects ระหว่างเดือนปัจจุบันและเดือนก่อนหน้า\r\n **/\r\nexport async function getDefectCategory(req: Request, res: Response) {\r\n  try {\r\n    const { startDate, endDate, patrolId, zoneId } = req.query;\r\n\r\n    // เงื่อนไขกรอง defect ตาม patrolId\r\n    const patrolFilter: any = {\r\n      patrolResult: {\r\n        patrolId: Number(patrolId),\r\n      },\r\n    };\r\n\r\n    // สร้างตัวกรองสำหรับวันที่ ถ้ามี startDate และ endDate\r\n    let dateFilter: any = {};\r\n    if (startDate || endDate) {\r\n      dateFilter = {\r\n        ...(startDate && { gte: new Date(startDate as string) }),\r\n        ...(endDate && { lte: new Date(endDate as string) }),\r\n      };\r\n    }\r\n    // สร้างตัวกรองสำหรับ zoneId ถ้ามี zoneId\r\n    let zoneFilter: any = {};\r\n    if (zoneId) {\r\n      zoneFilter = {\r\n        patrolResult: {\r\n          itemZone: {\r\n            zone: {\r\n              id: parseInt(zoneId as string, 10),\r\n            },\r\n          },\r\n        },\r\n      };\r\n    }\r\n    const allDefects = await prisma.defect.findMany({\r\n      where: {\r\n        ...(patrolId ? patrolFilter : { startTime: dateFilter, ...zoneFilter }),\r\n      },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            email: true,\r\n            username: true,\r\n            role: true,\r\n            profile: {\r\n              select: {\r\n                tel: true,\r\n                name: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        images: {\r\n          include: {\r\n            image: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    role: true,\r\n                    email: true,\r\n                    createdAt: true,\r\n                    username: true,\r\n                    profile: {\r\n                      select: {\r\n                        tel: true,\r\n                        name: true,\r\n                        image: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            username: true,\r\n            profile: {\r\n              select: {\r\n                tel: true,\r\n                name: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        patrolResult: {\r\n          select: {\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  include: {\r\n                    supervisor: {\r\n                      select: {\r\n                        username: true,\r\n                        email: true,\r\n                        role: true,\r\n                        profile: {\r\n                          select: {\r\n                            tel: true,\r\n                            name: true,\r\n                            image: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!allDefects) {\r\n      res.status(404).json({ message: \"Defect not found\" });\r\n      return;\r\n    }\r\n\r\n    // คำนวณ defectCategory\r\n    const typeColorMap: Record<string, string> = {\r\n      environment: \"hsl(var(--primary))\",\r\n      safety: \"hsl(var(--green))\",\r\n      maintenance: \"hsl(var(--destructive))\",\r\n    };\r\n\r\n    let defectCategoryMap: Record<\r\n      string,\r\n      { type: string; amounts: number; fill: string }\r\n    > = {};\r\n    allDefects.forEach((defect) => {\r\n      const type = defect.type || \"Unknown\";\r\n      if (!defectCategoryMap[type]) {\r\n        defectCategoryMap[type] = {\r\n          type,\r\n          amounts: 0,\r\n          fill: typeColorMap[type] || \"hsl(var(--chart-1))\",\r\n        };\r\n      }\r\n      defectCategoryMap[type].amounts++;\r\n    });\r\n\r\n    const defectCategory = Object.values(defectCategoryMap);\r\n\r\n    // คำนวณ trend\r\n    const currentMonthStart = startDate\r\n      ? new Date(startDate as string)\r\n      : new Date();\r\n    currentMonthStart.setDate(1);\r\n    currentMonthStart.setHours(0, 0, 0, 0);\r\n\r\n    const currentMonthEnd = new Date(currentMonthStart);\r\n    currentMonthEnd.setMonth(currentMonthEnd.getMonth() + 1);\r\n    currentMonthEnd.setMilliseconds(-1);\r\n\r\n    const previousMonthStart = new Date(currentMonthStart);\r\n    previousMonthStart.setMonth(previousMonthStart.getMonth() - 1);\r\n\r\n    const previousMonthEnd = new Date(currentMonthStart);\r\n    previousMonthEnd.setMilliseconds(-1);\r\n\r\n    // ดึง defect ของเดือนปัจจุบันและเดือนก่อนหน้า\r\n    const defectsCurrentMonth = await prisma.defect.count({\r\n      where: {\r\n        startTime: {\r\n          gte: currentMonthStart,\r\n          lte: currentMonthEnd,\r\n        },\r\n        ...zoneFilter,\r\n      },\r\n    });\r\n\r\n    const defectsPreviousMonth = await prisma.defect.count({\r\n      where: {\r\n        startTime: {\r\n          gte: previousMonthStart,\r\n          lte: previousMonthEnd,\r\n        },\r\n        ...zoneFilter,\r\n      },\r\n    });\r\n\r\n    let trend = 0;\r\n    if (defectsPreviousMonth > 0) {\r\n      trend =\r\n        ((defectsCurrentMonth - defectsPreviousMonth) / defectsPreviousMonth) *\r\n        100;\r\n    } else if (defectsCurrentMonth > 0) {\r\n      trend = 100;\r\n    }\r\n\r\n    let result = {\r\n      chartData: defectCategory,\r\n      trend: trend,\r\n    };\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Common Defects และคำนวณจำนวน Defects ที่เกิดขึ้นมากที่สุด\r\n * Input:\r\n * - req.query: { startDate: string, endDate: string, zoneId: string } (ตัวกรองสำหรับวันที่, zoneId)\r\n * Output: JSON object ที่ประกอบด้วย Common Defects 5 ตัวที่พบมากที่สุด พร้อมสีที่กำหนด\r\n **/\r\nexport async function getCommonDefects(req: Request, res: Response) {\r\n  try {\r\n    const { startDate, endDate, zoneId } = req.query;\r\n    // สร้างตัวกรองสำหรับวันที่ ถ้ามี startDate และ endDate\r\n    let dateFilter: any = {};\r\n    if (startDate || endDate) {\r\n      dateFilter = {\r\n        ...(startDate && { gte: new Date(startDate as string) }),\r\n        ...(endDate && { lte: new Date(endDate as string) }),\r\n      };\r\n    }\r\n    // สร้างตัวกรองสำหรับ zoneId ถ้ามี zoneId\r\n    let zoneFilter: any = {};\r\n    if (zoneId) {\r\n      zoneFilter = {\r\n        patrolResult: {\r\n          itemZone: {\r\n            zone: {\r\n              id: parseInt(zoneId as string, 10),\r\n            },\r\n          },\r\n        },\r\n      };\r\n    }\r\n    const allDefects = await prisma.defect.findMany({\r\n      where: {\r\n        startTime: dateFilter,\r\n        ...zoneFilter\r\n      },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username: true,\r\n            role: true,\r\n            profile: {\r\n              select: {\r\n                tel: true,\r\n                name: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        images: {\r\n          include: {\r\n            image: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    role: true,\r\n                    email: true,\r\n                    createdAt: true,\r\n                    username: true,\r\n                    profile: {\r\n                      select: {\r\n                        tel: true,\r\n                        name: true,\r\n                        image: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            username: true,\r\n            profile: {\r\n              select: {\r\n                tel: true,\r\n                name: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        patrolResult: {\r\n          select: {\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  include: {\r\n                    supervisor: {\r\n                      select: {\r\n                        username: true,\r\n                        email: true,\r\n                        role: true,\r\n                        profile: {\r\n                          select: {\r\n                            tel: true,\r\n                            name: true,\r\n                            image: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!allDefects) {\r\n      res.status(404).json({ message: \"Defect not found\" });\r\n      return;\r\n    }\r\n\r\n    // คำนวณ commonDefects\r\n    let defectNameMap: Record<\r\n      string,\r\n      { name: string; amounts: number; fill: string }\r\n    > = {};\r\n\r\n    allDefects.forEach((defect) => {\r\n      const name = defect.name || \"Unknown Defect\";\r\n      if (!defectNameMap[name]) {\r\n        defectNameMap[name] = {\r\n          name,\r\n          amounts: 0,\r\n          fill: \"\", // ค่าสีจะกำหนดภายหลัง\r\n        };\r\n      }\r\n      defectNameMap[name].amounts++;\r\n    });\r\n\r\n    // แปลงเป็นอาเรย์ + เรียงลำดับจากมากไปน้อย + เอาแค่ 5 ตัวแรก\r\n    const commonDefects = Object.values(defectNameMap)\r\n      .sort((a, b) => b.amounts - a.amounts) // เรียงจากมากไปน้อย\r\n      .slice(0, 5); // เอาแค่ 5 อันแรก\r\n\r\n    // กำหนดสีตามลำดับ ไม่สุ่ม\r\n    commonDefects.forEach((defect, index) => {\r\n      defect.fill = `hsl(var(--chart-${index + 1}))`; // ใช้ index + 1 เพื่อให้เริ่มที่ 1\r\n    });\r\n\r\n    let result = commonDefects;\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับคำนวณอัตราการเสร็จสมบูรณ์ของการตรวจตรา (Patrol Completion Rate)\r\n * Input:\r\n * - req.query: { startDate: string, endDate: string } (ตัวกรองสำหรับวันที่)\r\n * Output: JSON object ที่ประกอบด้วยข้อมูลสำหรับแสดงผลในกราฟ Radial chart และเปอร์เซ็นต์ของการตรวจสอบที่เสร็จสมบูรณ์\r\n **/\r\nexport async function getPatrolCompletionRate(req: Request, res: Response) {\r\n  try {\r\n    const { startDate, endDate } = req.query;\r\n    // สร้างตัวกรองสำหรับวันที่ ถ้ามี startDate และ endDate\r\n    let dateFilter;\r\n    if (startDate || endDate) {\r\n      dateFilter = {\r\n        ...(startDate && { gte: new Date(startDate as string) }),\r\n        ...(endDate && { lte: new Date(endDate as string) }),\r\n      };\r\n    }\r\n    const allPatrols = await prisma.patrol.findMany({\r\n      where: {\r\n        date: dateFilter,\r\n        status: \"completed\",\r\n      },\r\n      include: {\r\n        results: {\r\n          select: {\r\n            defects: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n    if (!allPatrols) {\r\n      res.status(404).json({ message: \"Patrol not found\" });\r\n      return;\r\n    }\r\n\r\n    // คำนวณ patrolCompletionRate\r\n    const completionRate = {\r\n      noDefect: 0,\r\n      withDefect: 0,\r\n    };\r\n\r\n    allPatrols.forEach((patrol) => {\r\n      // ตรวจสอบว่า patrol นี้มี defects หรือไม่\r\n      const hasDefects = patrol.results.some(\r\n        (result) => result.defects.length > 0\r\n      );\r\n\r\n      if (hasDefects) {\r\n        completionRate.withDefect += 1;\r\n      } else {\r\n        completionRate.noDefect += 1;\r\n      }\r\n    });\r\n\r\n    // คำนวณ trend\r\n    const currentMonthStart = startDate\r\n      ? new Date(startDate as string)\r\n      : new Date();\r\n    currentMonthStart.setDate(1);\r\n    currentMonthStart.setHours(0, 0, 0, 0);\r\n\r\n    const currentMonthEnd = new Date(currentMonthStart);\r\n    currentMonthEnd.setMonth(currentMonthEnd.getMonth() + 1);\r\n    currentMonthEnd.setMilliseconds(-1);\r\n\r\n    const previousMonthStart = new Date(currentMonthStart);\r\n    previousMonthStart.setMonth(previousMonthStart.getMonth() - 1);\r\n\r\n    const previousMonthEnd = new Date(currentMonthStart);\r\n    previousMonthEnd.setMilliseconds(-1);\r\n\r\n    const patrolsCurrentMonth = await prisma.patrol.findMany({\r\n      where: {\r\n        date: {\r\n          gte: currentMonthStart,\r\n          lte: currentMonthEnd,\r\n        },\r\n        status: \"completed\",\r\n      },\r\n      include: {\r\n        results: {\r\n          select: {\r\n            defects: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const currentCompletionRate = {\r\n      noDefect: 0,\r\n      withDefect: 0,\r\n    };\r\n\r\n    patrolsCurrentMonth.forEach((patrol) => {\r\n      // ตรวจสอบว่า patrol นี้มี defects หรือไม่\r\n      const hasDefects = patrol.results.some(\r\n        (result) => result.defects.length > 0\r\n      );\r\n\r\n      if (hasDefects) {\r\n        currentCompletionRate.withDefect += 1;\r\n      } else {\r\n        currentCompletionRate.noDefect += 1;\r\n      }\r\n    });\r\n\r\n    const patrolsPreviousMonth = await prisma.patrol.findMany({\r\n      where: {\r\n        date: {\r\n          gte: previousMonthStart,\r\n          lte: previousMonthEnd,\r\n        },\r\n        status: \"completed\",\r\n      },\r\n      include: {\r\n        results: {\r\n          select: {\r\n            defects: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const prevCompletionRate = {\r\n      noDefect: 0,\r\n      withDefect: 0,\r\n    };\r\n\r\n    patrolsPreviousMonth.forEach((patrol) => {\r\n      // ตรวจสอบว่า patrol นี้มี defects หรือไม่\r\n      const hasDefects = patrol.results.some(\r\n        (result) => result.defects.length > 0\r\n      );\r\n\r\n      if (hasDefects) {\r\n        prevCompletionRate.withDefect += 1;\r\n      } else {\r\n        prevCompletionRate.noDefect += 1;\r\n      }\r\n    });\r\n\r\n    const percent = (completionRate.noDefect / allPatrols.length) * 100;\r\n    const currentPercent =\r\n      (currentCompletionRate.noDefect / patrolsCurrentMonth.length) * 100;\r\n    const prevPercent =\r\n      (prevCompletionRate.noDefect / patrolsPreviousMonth.length) * 100;\r\n    let trend = calculateTrend(8, 3);\r\n\r\n    // สร้างข้อมูลสำหรับแสดงผลใน radial chart\r\n    const patrolCompletionRate = [\r\n      {\r\n        noDefect: completionRate.noDefect,\r\n        withDefect: completionRate.withDefect,\r\n      },\r\n    ];\r\n\r\n    let result = {\r\n      chartData: allPatrols.length !== 0 ? patrolCompletionRate : [],\r\n      percent: !startDate && !endDate ? percent : currentPercent,\r\n      trend: trend,\r\n    }\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล defects ที่แจ้งปัญหาจากการตรวจตรา (patrol) โดยอ้างอิงจาก patrolId\r\n * Input:\r\n * - req.params.id: patrolId (รหัสของการตรวจสอบ)\r\n * Output: JSON object ที่ประกอบด้วยข้อมูลของ defects ที่ถูกรายงาน พร้อมข้อมูลของ zone ที่เกี่ยวข้อง\r\n **/\r\nexport async function getDefectReported(req: Request, res: Response) {\r\n  try {\r\n    const patrolId = parseInt(req.params.id, 10);\r\n\r\n    const patrol = await prisma.patrol.findFirst({\r\n      where: { id: patrolId },\r\n      select: {\r\n        results: {\r\n          select: {\r\n            zoneId: true,\r\n            defects: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                type: true,\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    username: true,\r\n                    role: true,\r\n                    profile: {\r\n                      select: {\r\n                        id: true,\r\n                        tel: true,\r\n                        name: true,\r\n                        image: { select: { path: true } }\r\n                      }\r\n                    }\r\n                  }\r\n                },\r\n                startTime: true,\r\n                status: true,\r\n              }\r\n            },\r\n          },\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!patrol) {\r\n      res.status(404).json({ message: \"patrol not found\" });\r\n      return;\r\n    }\r\n\r\n    // ดึง zone ข้อมูลตาม zoneId\r\n    const zoneIds = patrol.results.map(result => result.zoneId);\r\n    const zones = await prisma.zone.findMany({\r\n      where: { id: { in: zoneIds } },\r\n      select: { id: true, name: true }\r\n    });\r\n\r\n    // รวม defects ทั้งหมดจาก results และผูก zone เข้าไป\r\n    const defects = patrol.results.flatMap(result =>\r\n      result.defects.map(defect => ({\r\n        ...defect,\r\n        zone: zones.find(zone => zone.id === result.zoneId) || {}\r\n      }))\r\n    );\r\n\r\n    res.status(200).json(defects);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\defect-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fs' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeStamp' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tr' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from \"@Utils/database.js\";\r\nimport { Request, Response } from \"express\";\r\nimport { createNotification, deleteImages, handleDefectImagesUpdate } from \"@Controllers/util-controller.js\";\r\nimport { DefectStatus, ItemType, NotificationType } from \"@prisma/client\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport { timeStamp } from \"console\";\r\nimport { tr } from \"@faker-js/faker\";\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้าง Defect ใหม่\r\n * Input:\r\n * - req as any user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.body: { name: String, description: String, type: ItemType, defectUserId: Int, patrolResultId: Int, supervisorId: Int }\r\n * Output: JSON object ข้อมูล Defect ที่ถูกสร้าง พร้อมกับอัปเดตสถานะของ patrolResult\r\n **/\r\nexport async function createDefect(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const {\r\n      name,\r\n      description,\r\n      type,\r\n      defectUserId,\r\n      patrolResultId,\r\n      supervisorId,\r\n    } = req.body;\r\n    const validPatrol = await prisma.patrol.findFirst({\r\n      //เช็คว่า Patrol มีอยู่จริงหรือไม่\r\n      where: {\r\n        results: {\r\n          some: {\r\n            id: parseInt(patrolResultId),\r\n          },\r\n        },\r\n        patrolChecklists: {\r\n          some: {\r\n            userId: parseInt(userId),\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!validPatrol) {\r\n      // response 404 ถ้า Patrol ไม่มีอยู่จริง\r\n      res.status(404).json({\r\n        message:\r\n          \"You are not associated with this Patrol or PatrolResult not found\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    const newDefect = await prisma.defect.create({\r\n      //สร้าง Defect\r\n      data: {\r\n        name: name,\r\n        description: description,\r\n        type: type,\r\n        status: \"reported\" as DefectStatus,\r\n        startTime: new Date(),\r\n        user: { connect: { id: parseInt(defectUserId) } },\r\n        supervisor: { connect: { id: parseInt(supervisorId) } },\r\n        patrolResult: { connect: { id: parseInt(patrolResultId) } },\r\n      },\r\n    });\r\n\r\n    const updateResult = async (patrolResultId: string) => {\r\n      //อัพเดต ข้อมูลที่เกี่ยวข้อง\r\n      try {\r\n        const result = await prisma.patrolResult.findUnique({\r\n          where: {\r\n            id: parseInt(patrolResultId),\r\n          },\r\n        });\r\n\r\n        if (!result) {\r\n          console.error(\"Patrol result not found\");\r\n          return;\r\n        }\r\n\r\n        const updatedResult = await prisma.patrolResult.update({\r\n          where: { id: parseInt(patrolResultId) },\r\n          data: {\r\n            status: false,\r\n          },\r\n        });\r\n\r\n        return updatedResult;\r\n      } catch (error) {\r\n        console.error(\"Error updating patrol result:\", error);\r\n      }\r\n    };\r\n    updateResult(patrolResultId);\r\n\r\n    const message = `report_defect`;\r\n    const supervisor = parseInt(supervisorId, 10);\r\n\r\n    await createNotification({\r\n      //สร้าง Notifications แจ้งเตือนผู้ใช้ที่เดี่ยวข้อง\r\n      message: message,\r\n      type: \"request\" as NotificationType,\r\n      url: `/defect/${newDefect.id}`,\r\n      userId: supervisor,\r\n    });\r\n\r\n    let result = await prisma.defect.findFirst({\r\n      // Response\r\n      where: { id: newDefect.id },\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            patrol: {\r\n              select: {\r\n                id: true,\r\n                preset: {\r\n                  select: {\r\n                    title: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  select: {\r\n                    name: true,\r\n                    supervisor: {\r\n                      select: {\r\n                        id: true,\r\n                        email:true,\r\n                        username:true,\r\n                        role:true,\r\n                        profile: {\r\n                          select: {\r\n                            tel:true,\r\n                            name:true,\r\n                            image: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        images: {\r\n          select: {\r\n            image: {\r\n              select: {\r\n                id: true,\r\n                path: true,\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    email: true,\r\n                    role: true,\r\n                    department: true,\r\n                    createdAt: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username:true,\r\n            email:true,\r\n            role:true,\r\n            profile: {\r\n              select: {\r\n                tel:true,\r\n                name: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            username:true,\r\n            role:true,\r\n            profile: {\r\n              select: {\r\n                tel:true,\r\n                name: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        }\r\n      },\r\n    });\r\n\r\n    res.status(201).json(result);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Defect\r\n * Input:\r\n * - req.params: { id: Int} (ID ของ Defect)\r\n * Output: JSON object ข้อมูล Defect และข้อมูล patrolResult ที่เกี่ยวข้อง\r\n **/\r\nexport async function getDefect(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    const defect = await prisma.defect.findUnique({\r\n      // หา Defect\r\n      where: {\r\n        id: Number(id),\r\n      },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username:true,\r\n            role:true,\r\n            profile: {\r\n              select: {\r\n                tel:true,\r\n                name: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        images: {\r\n          include: {\r\n            image: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    role: true,\r\n                    email: true,\r\n                    username:true,\r\n                    createdAt: true,\r\n                    profile: {\r\n                      select: {\r\n                        tel:true,\r\n                        name:true,\r\n                        image: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            username:true,\r\n            createdAt: true,\r\n            profile: {\r\n              select: {\r\n                tel:true,\r\n                name:true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        patrolResult: {\r\n          select: {\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  include: {\r\n                    supervisor: {\r\n                      select: {\r\n                        username:true,\r\n                        email:true,\r\n                        role:true,\r\n                        profile: {\r\n                          select: {\r\n                            tel:true,\r\n                            name: true,\r\n                            image: true\r\n                          }\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!defect) {\r\n      res.status(404).json({ message: \"Defect not found\" });\r\n      return;\r\n    }\r\n\r\n    let result = defect; // Response\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Defect ทั้งหมด\r\n * Input:\r\n * - req as any: user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.query: { status: DefectStatus, type: ItemType, startDate: Date, endDate: Date, search:String }\r\n * Output: JSON array ข้อมูล Defect ทั้งหมด รวมถึงข้อมูล patrolResult และ user ที่เกี่ยวข้อง\r\n **/\r\nexport async function getAllDefects(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const { status, type, startDate, endDate, search } = req.query;\r\n    // สร้างเงื่อนไขหลัก\r\n    const whereConditions: any = {\r\n      supervisorId: userId,\r\n    };\r\n\r\n    const andConditions: any[] = [];\r\n\r\n    // เงื่อนไขการกรองตาม status\r\n    if (status) {\r\n      andConditions.push({ status: status });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตาม preset\r\n    if (type) {\r\n      const typeArray = (type as string).split(\",\"); // แยกค่าด้วย comma\r\n      const orTypeConditions = typeArray.map((t) => ({ type: t })); // สร้าง array ของ OR เงื่อนไข\r\n\r\n      andConditions.push({ OR: orTypeConditions });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตามช่วงเวลา\r\n    if (startDate && endDate) {\r\n      const start = new Date(startDate as string);\r\n      const end = new Date(endDate as string);\r\n\r\n      if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\r\n        andConditions.push({\r\n          startTime: {\r\n            gte: start,\r\n            lte: end,\r\n          },\r\n        });\r\n      } else {\r\n        console.error(\"Invalid date range:\", startDate, endDate);\r\n      }\r\n    }\r\n\r\n    // เงื่อนไขการค้นหา (search)\r\n    if (search) {\r\n      const searchId = parseInt(search as string, 10);\r\n\r\n      function mapSearchToStatus(search: string): DefectStatus | null {\r\n        const searchLower = search.toLowerCase();\r\n\r\n        // ตรวจสอบความใกล้เคียงกับค่าของ DefectStatus\r\n        if (searchLower.startsWith(\"rep\")) {\r\n          return DefectStatus.reported;\r\n        } else if (searchLower.startsWith(\"in\")) {\r\n          return DefectStatus.in_progress;\r\n        } else if (searchLower.startsWith(\"pe\")) {\r\n          return DefectStatus.pending_inspection;\r\n        } else if (searchLower.startsWith(\"res\")) {\r\n          return DefectStatus.resolved;\r\n        } else if (searchLower.startsWith(\"co\")) {\r\n          return DefectStatus.completed;\r\n        }\r\n        // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n        return null;\r\n      }\r\n\r\n      function mapSearchToType(search: string): ItemType | null {\r\n        const searchLower = search.toLowerCase();\r\n\r\n        // ตรวจสอบความใกล้เคียงกับค่าของ DefectStatus\r\n        if (searchLower.startsWith(\"sa\")) {\r\n          return ItemType.safety;\r\n        } else if (searchLower.startsWith(\"en\")) {\r\n          return ItemType.environment;\r\n        } else if (searchLower.startsWith(\"ma\")) {\r\n          return ItemType.maintenance;\r\n        }\r\n\r\n        // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n        return null;\r\n      }\r\n\r\n      const mappedStatus = mapSearchToStatus(search as string);\r\n      const mappedTypes = mapSearchToType(search as string);\r\n\r\n      const orConditions = [];\r\n\r\n      if (!isNaN(searchId)) {\r\n        orConditions.push({ id: searchId });\r\n      }\r\n\r\n      // ถ้า mappedStatus มีค่า (ค้นหาตรงกับสถานะ)\r\n      if (mappedStatus) {\r\n        orConditions.push({ status: mappedStatus as DefectStatus });\r\n      }\r\n\r\n      // ถ้า mappedTypes มีค่า (ค้นหาตรงกับชนิด)\r\n      if (mappedTypes) {\r\n        orConditions.push({ type: mappedTypes as ItemType });\r\n      }\r\n\r\n      // ถ้ามีค่า preset title\r\n      orConditions.push({\r\n        name: {\r\n          contains: search as string,\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        user: {\r\n          profile: {\r\n            name: {\r\n              contains: search as string,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // ถ้ามีเงื่อนไขใน OR ให้เพิ่มเข้าไปใน AND\r\n      if (orConditions.length > 0) {\r\n        andConditions.push({ OR: orConditions });\r\n      }\r\n    }\r\n\r\n    // ถ้ามีเงื่อนไขเพิ่มเติมให้เพิ่มเข้าไปใน AND\r\n    if (andConditions.length > 0) {\r\n      whereConditions.AND = andConditions;\r\n    }\r\n\r\n    const defects = await prisma.defect.findMany({\r\n      where: whereConditions,\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username:true,\r\n            email:true,\r\n            role:true,\r\n            profile: {\r\n              select: {\r\n                tel:true,\r\n                name: true,\r\n                image: true\r\n              }\r\n            },\r\n          },\r\n        },\r\n        patrolResult: {\r\n          select: {\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            username:true,\r\n            profile: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                tel: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        images: {\r\n          select: {\r\n            image: {\r\n              select: {\r\n                id: true,\r\n                path: true,\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    role: true,\r\n                    email: true,\r\n                    createdAt: true,\r\n                    username:true,\r\n                    profile: {\r\n                      select: {\r\n                        id: true,\r\n                        name: true,\r\n                        tel: true,\r\n                        image: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    let result = defects;\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดต Defect\r\n * Input:\r\n * - req.params: { id: Int} (ID ของ Defect ที่จะอัปเดต)\r\n * - req.body: {name: String, description: String, type: ItemType, status: DefectStatus, defectUserId: Int, patrolResultId: Int , supervisorId: Int  , deleteExistingImages: boolean}\r\n * - req.file: Array<Express.Multer.File> (ไฟล์รูปภาพใหม่)\r\n * Output: JSON object ข้อมูล Defect หลังการอัปเดต\r\n **/\r\nexport async function updateDefect(req: Request, res: Response): Promise<void> {\r\n  try {\r\n    const { id } = req.params;\r\n    const {\r\n      name,\r\n      description,\r\n      type,\r\n      status,\r\n      defectUserId,\r\n      supervisorId,\r\n      patrolResultId,\r\n      deleteExistingImages,\r\n    } = req.body;\r\n    const newImageFiles = req.files as Express.Multer.File[];\r\n\r\n    const defect = await prisma.defect.findUnique({\r\n      where: { id: Number(id) },\r\n    });\r\n    if (!defect) {\r\n      //เช็ค defect\r\n      res.status(404).json({ message: \"Defect not found\" });\r\n      return;\r\n    }\r\n\r\n    if (newImageFiles?.length) {\r\n      await handleDefectImagesUpdate(Number(id), status, {\r\n        updatedBy: status === 'reported'\r\n          ? Number(defectUserId)\r\n          : Number(supervisorId),\r\n        supervisorId: Number(supervisorId),\r\n        deleteExistingImages: deleteExistingImages === 'true',\r\n        files: newImageFiles\r\n      })\r\n    }\r\n    // สร้างข้อมูลสำหรับการอัปเดต Defect\r\n    const updateData: any = {};\r\n    // อัปเดตข้อมูลของ Defect หากมีการเปลี่ยนแปลง\r\n    if (name !== undefined) updateData.name = name;\r\n    if (description !== undefined) updateData.description = description;\r\n    if (type !== undefined) updateData.type = type;\r\n    if (status !== undefined) updateData.status = status;\r\n\r\n    if (defectUserId !== undefined) {\r\n      updateData.user = { connect: { id: parseInt(defectUserId, 10) } };\r\n    }\r\n\r\n    if (patrolResultId !== undefined) {\r\n      updateData.patrolResult = {\r\n        connect: { id: parseInt(patrolResultId, 10) },\r\n      };\r\n    }\r\n\r\n    // ทำการอัปเดต Defect ด้วยข้อมูลที่มี\r\n    await prisma.defect.update({\r\n      where: { id: Number(id) },\r\n      data: updateData,\r\n    });\r\n\r\n    let message = null;\r\n    let notiType = null;\r\n    let url = null;\r\n    let receive = null;\r\n\r\n    if (status === (\"in_progress\" as DefectStatus)) {\r\n      (message = \"defect_accept\"),\r\n        (notiType = \"information\" as NotificationType);\r\n      url = `/patrol-defect`;\r\n      receive = defectUserId;\r\n    } else if (status === (\"resolved\" as DefectStatus)) {\r\n      message = \"defect_resolved\";\r\n      notiType = \"information\" as NotificationType;\r\n      url = `/patrol-defect`;\r\n      receive = defectUserId;\r\n    } else if (status === (\"pending_inspection\" as DefectStatus)) {\r\n      message = \"defect_pending_inspection\";\r\n      notiType = \"request\" as NotificationType;\r\n      url = `/defect/${id}`;\r\n      receive = supervisorId;\r\n    } else if (status === (\"completed\" as DefectStatus)) {\r\n      message = \"defect_completed\";\r\n      notiType = \"information\" as NotificationType;\r\n      url = `/defect/${id}`;\r\n      receive = supervisorId;\r\n    }\r\n\r\n    if (message) {\r\n      await createNotification({\r\n        message,\r\n        type: notiType,\r\n        url,\r\n        userId: parseInt(receive),\r\n      });\r\n    }\r\n\r\n    const result = await prisma.defect.findUnique({\r\n      // Response\r\n      where: { id: Number(id) },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username:true,\r\n            email:true,\r\n            role:true,\r\n            profile: {\r\n              select: {\r\n                tel:true,\r\n                name: true,\r\n                image: true\r\n              }\r\n            },\r\n          },\r\n        },\r\n        patrolResult: {\r\n          select: {\r\n            patrol: {\r\n              select: {\r\n                id: true,\r\n                preset: {\r\n                  select: {\r\n                    title: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: {\r\n                  select: {\r\n                    name: true,\r\n                    supervisor: {\r\n                      select: {\r\n                        id: true,\r\n                        username:true,\r\n                        email:true,\r\n                        role:true,\r\n                        profile: {\r\n                          select: {\r\n                            tel:true,\r\n                            name:true,\r\n                            image: true,\r\n                          },\r\n                        },\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        images: {\r\n          select: {\r\n            image: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    email: true,\r\n                    role: true,\r\n                    department: true,\r\n                    createdAt: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            username:true,\r\n            profile: {\r\n              select: {\r\n                tel:true,\r\n                name:true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    res.status(200).json(result);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบ Defect\r\n * Input:\r\n * - (req as any).user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.params: { id: Int} (ID ของ Defect ที่จะลบ)\r\n * Output: JSON message ยืนยันการลบ Defect สำเร็จ\r\n **/\r\nexport async function deleteDefect(req: Request, res: Response): Promise<void> {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const { id } = req.params;\r\n\r\n    // ตรวจสอบ defect ว่ามีอยู่จริง\r\n    const defect = await prisma.defect.findUnique({\r\n      where: { id: Number(id) },\r\n    });\r\n    if (!defect) {\r\n      res.status(404).json({ message: \"Defect not found\" });\r\n      return;\r\n    }\r\n    const validPatrol = await prisma.patrol.findFirst({\r\n      where: {\r\n        results: { some: { id: defect.patrolResultId } },\r\n        patrolChecklists: { some: { userId } },\r\n      },\r\n    });\r\n    if (!validPatrol) {\r\n      res.status(403).json({ message: \"Unauthorized access\" });\r\n      return;\r\n    }\r\n\r\n    // ค้นหาภาพที่เกี่ยวข้องกับ Defect นี้\r\n    const existingDefectImages = await prisma.defectImage.findMany({\r\n      where: { defectId: Number(id) },\r\n      select: { imageId: true },\r\n    });\r\n    // ดึง IDs ของภาพที่จะลบ\r\n    const imageIdsToDelete = existingDefectImages.map((img) => img.imageId);\r\n    // ค้นหาข้อมูลภาพที่จะลบ\r\n    await deleteImages(imageIdsToDelete);\r\n\r\n    // ลบ defect หลัก\r\n    await prisma.defect.delete({\r\n      where: { id: Number(id) },\r\n    });\r\n    res.status(200).json({ message: \"Defect deleted successfully\" });\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Comment ทั้งหมด\r\n * Input:\r\n * - req as any:user.userId: Int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * - req.query:{ status:DefectStatus, startDate:Date, endDate:Date, search:String }\r\n * Output: JSON array ข้อมูล Comment ทั้งหมด รวมถึงข้อมูล patrolResult และ user ที่เกี่ยวข้อง\r\n **/\r\nexport async function getAllComments(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const { status, startDate, endDate, search } = req.query;\r\n    // สร้างเงื่อนไขหลัก\r\n    const whereConditions: any = {\r\n      supervisorId: userId,\r\n    };\r\n\r\n    const andConditions: any[] = [];\r\n\r\n    // เงื่อนไขการกรองตาม status\r\n    if (status !== undefined) {\r\n      const statusBoolean = status === \"true\";\r\n      andConditions.push({ status: statusBoolean });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตามช่วงเวลา\r\n    if (startDate && endDate) {\r\n      const start = new Date(startDate as string);\r\n      const end = new Date(endDate as string);\r\n\r\n      if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\r\n        andConditions.push({\r\n          timestamp: {\r\n            gte: start,\r\n            lte: end,\r\n          },\r\n        });\r\n      } else {\r\n        console.error(\"Invalid date range:\", startDate, endDate);\r\n      }\r\n    }\r\n\r\n    // เงื่อนไขการค้นหา (search)\r\n    if (search) {\r\n      const searchId = parseInt(search as string, 10);\r\n\r\n      function mapSearchToStatus(search: string): boolean | null {\r\n        const searchLower = search.toLowerCase();\r\n\r\n        // ตรวจสอบความใกล้เคียงกับค่าของ CommentStatus\r\n        if (searchLower.startsWith(\"pe\")) {\r\n          return false;\r\n        } else if (searchLower.startsWith(\"co\")) {\r\n          return true;\r\n        }\r\n        // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n        return null;\r\n      }\r\n\r\n      const mappedStatus = mapSearchToStatus(search as string);\r\n\r\n      const orConditions = [];\r\n\r\n      if (!isNaN(searchId)) {\r\n        orConditions.push({ id: searchId });\r\n      }\r\n\r\n      // ถ้า mappedStatus มีค่า (ค้นหาตรงกับสถานะ)\r\n      if (mappedStatus != undefined) {\r\n        orConditions.push({ status: mappedStatus as boolean });\r\n      }\r\n\r\n      orConditions.push({\r\n        message: {\r\n          contains: search as string,\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        user: {\r\n          profile: {\r\n            name: {\r\n              contains: search as string,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        patrolResult: {\r\n          itemZone: {\r\n            zone: {\r\n              name: {\r\n                contains: search as string,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        patrolResult: {\r\n          itemZone: {\r\n            item: {\r\n              name: {\r\n                contains: search as string,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // ถ้ามีเงื่อนไขใน OR ให้เพิ่มเข้าไปใน AND\r\n      if (orConditions.length > 0) {\r\n        andConditions.push({ OR: orConditions });\r\n      }\r\n    }\r\n\r\n    // ถ้ามีเงื่อนไขเพิ่มเติมให้เพิ่มเข้าไปใน AND\r\n    if (andConditions.length > 0) {\r\n      whereConditions.AND = andConditions;\r\n    }\r\n\r\n    // บันทึก query ที่สร้างขึ้นสำหรับการดีบัก\r\n\r\n    const comments = await prisma.comment.findMany({\r\n      where: whereConditions,\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: true,\r\n                item: {\r\n                  include: {\r\n                    checklist: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            username:true,\r\n            profile: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                tel: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    let result = comments;\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับยืนยัน Comment\r\n * Input:\r\n * - req.params.id: number (ID ของ Comment ที่ต้องการยืนยัน)\r\n * Output: JSON object ข้อมูล Comment หลังจากยืนยัน\r\n **/\r\nexport async function confirmComment(req: Request, res: Response) {\r\n  try {\r\n    const commentId = parseInt(req.params.id, 10);\r\n\r\n    await prisma.comment.update({\r\n      where: {\r\n        id: commentId,\r\n      },\r\n      data: {\r\n        status: true,\r\n      },\r\n    });\r\n\r\n    const result = await prisma.comment.findUnique({\r\n      where: {\r\n        id: commentId,\r\n      },\r\n      include: {\r\n        patrolResult: {\r\n          select: {\r\n            zoneId: true,\r\n            itemZone: {\r\n              select: {\r\n                zone: true,\r\n                item: {\r\n                  include: {\r\n                    checklist: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            email: true,\r\n            createdAt: true,\r\n            username:true,\r\n            profile: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                tel: true,\r\n                image: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const message = `confirm_comment`;\r\n    await createNotification({\r\n      message: message,\r\n      type: \"information\" as NotificationType,\r\n      url: ``,\r\n      userId: result?.user.id,\r\n    });\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\location-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'itemZones' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":356,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":356,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import prisma from \"@Utils/database.js\";\r\nimport { Request, Response } from \"express\";\r\nimport { calculateTrend, createNotification } from \"@Controllers/util-controller.js\";\r\nimport { DefectStatus, ItemType, NotificationType } from \"@prisma/client\";\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Zone โดยการกรองด้วยเงื่อนไขต่าง ๆ และคำนวณข้อมูลสถิติเกี่ยวกับ Defect\r\n * Input:\r\n * - req.params.id: number (ID ของ Zone)\r\n * - req.query: {\r\n *     dashboard: string (ตัวเลือกการแสดงผลแดชบอร์ด),\r\n *     startDate: string (วันที่เริ่มต้นในการกรองข้อมูล),\r\n *     endDate: string (วันที่สิ้นสุดในการกรองข้อมูล),\r\n *     status: string (สถานะของ Defect ที่ต้องการกรอง),\r\n *     type: string (ชนิดของ Defect ที่ต้องการกรอง),\r\n *     search: string (คำค้นหาที่ใช้ในการกรองข้อมูล)\r\n * }\r\n * - req.user: { role: string } (บทบาทของผู้ใช้งานที่ล็อกอิน)\r\n * Output: JSON object ที่ประกอบไปด้วยข้อมูล Zone, สถิติเกี่ยวกับ Defect, และข้อมูลแดชบอร์ด\r\n */\r\nexport async function getZone(req: Request, res: Response) {\r\n  try {\r\n    const { dashboard, startDate, endDate, status, type, search } = req.query;\r\n    const zoneId = parseInt(req.params.id, 10)\r\n    const role = (req as any).user.role\r\n\r\n    // สร้างตัวกรองสำหรับวันที่ ถ้ามี startDate และ endDate\r\n    let dateFilter: any = {};\r\n    if (startDate || endDate) {\r\n      dateFilter = {\r\n        ...(startDate && { gte: new Date(startDate as string) }),\r\n        ...(endDate && { lte: new Date(endDate as string) }),\r\n      };\r\n    }\r\n\r\n    // สร้างเงื่อนไขหลัก\r\n    const whereConditions: any = {\r\n      startTime: dateFilter\r\n    };\r\n\r\n    const andConditions: any[] = [];\r\n\r\n    // เงื่อนไขการกรองตาม status\r\n    if (status) {\r\n      andConditions.push({ status: status });\r\n    }\r\n\r\n    // เงื่อนไขการกรองตาม type\r\n    if (type) {\r\n      const typeArray = (type as string).split(\",\"); // แยกค่าด้วย comma\r\n      const orTypeConditions = typeArray.map((t) => ({ type: t })); // สร้าง array ของ OR เงื่อนไข\r\n\r\n      andConditions.push({ OR: orTypeConditions });\r\n    }\r\n\r\n    function mapSearchToStatus(search: string): DefectStatus | null {\r\n      const searchLower = search.toLowerCase();\r\n\r\n      // ตรวจสอบความใกล้เคียงกับค่าของ DefectStatus\r\n      if (searchLower.startsWith(\"rep\")) {\r\n        return DefectStatus.reported;\r\n      } else if (searchLower.startsWith(\"in\")) {\r\n        return DefectStatus.in_progress;\r\n      } else if (searchLower.startsWith(\"pe\")) {\r\n        return DefectStatus.pending_inspection;\r\n      } else if (searchLower.startsWith(\"res\")) {\r\n        return DefectStatus.resolved;\r\n      } else if (searchLower.startsWith(\"co\")) {\r\n        return DefectStatus.completed;\r\n      }\r\n      // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n      return null;\r\n    }\r\n\r\n    function mapSearchToType(search: string): ItemType | null {\r\n      const searchLower = search.toLowerCase();\r\n\r\n      // ตรวจสอบความใกล้เคียงกับค่าของ DefectStatus\r\n      if (searchLower.startsWith(\"sa\")) {\r\n        return ItemType.safety;\r\n      } else if (searchLower.startsWith(\"en\")) {\r\n        return ItemType.environment;\r\n      } else if (searchLower.startsWith(\"ma\")) {\r\n        return ItemType.maintenance;\r\n      }\r\n\r\n      // ถ้าไม่มีค่าใดที่ตรงกับการค้นหา\r\n      return null;\r\n    }\r\n\r\n    // เงื่อนไขการค้นหา (search)\r\n    if (search) {\r\n      const searchId = parseInt(search as string, 10);\r\n\r\n\r\n\r\n      const mappedStatus = mapSearchToStatus(search as string);\r\n      const mappedTypes = mapSearchToType(search as string);\r\n\r\n      const orConditions = [];\r\n\r\n      if (!isNaN(searchId)) {\r\n        orConditions.push({ id: searchId });\r\n      }\r\n\r\n      // ถ้า mappedStatus มีค่า (ค้นหาตรงกับสถานะ)\r\n      if (mappedStatus) {\r\n        orConditions.push({ status: mappedStatus as DefectStatus });\r\n      }\r\n\r\n      // ถ้า mappedTypes มีค่า (ค้นหาตรงกับชนิด)\r\n      if (mappedTypes) {\r\n        orConditions.push({ type: mappedTypes as ItemType });\r\n      }\r\n\r\n      orConditions.push({\r\n        name: {\r\n          contains: search as string,\r\n        },\r\n      });\r\n\r\n      orConditions.push({\r\n        user: {\r\n          profile: {\r\n            name: {\r\n              contains: search as string,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // ถ้ามีเงื่อนไขใน OR ให้เพิ่มเข้าไปใน AND\r\n      if (orConditions.length > 0) {\r\n        andConditions.push({ OR: orConditions });\r\n      }\r\n    }\r\n\r\n    // ถ้ามีเงื่อนไขเพิ่มเติมให้เพิ่มเข้าไปใน AND\r\n    if (andConditions.length > 0) {\r\n      whereConditions.AND = andConditions;\r\n    }\r\n\r\n    // Authorization Check\r\n    if (dashboard === \"true\" && role !== 'admin') {\r\n      res.status(403).json({\r\n        message: `Access Denied: Requires admin privileges`\r\n      })\r\n      return\r\n    }\r\n\r\n    if (!dashboard) {\r\n      const zone = await prisma.zone.findUnique({\r\n        where: { id: zoneId },\r\n        include: {\r\n          supervisor: {\r\n            select: {\r\n              id: true,\r\n              username: true,\r\n              email: true,\r\n              role: true,\r\n              department: true,\r\n              createdAt: true,\r\n              profile: { select: { image: true, tel: true, name: true } },\r\n            },\r\n          },\r\n        },\r\n      })\r\n\r\n      if (!zone) {\r\n        res.status(404).json({\r\n          message: \"Zone not found\"\r\n        })\r\n        return\r\n      }\r\n\r\n      res.status(200).json(zone)\r\n      return\r\n    }\r\n\r\n    const zoneWithData = await prisma.zone.findUnique({\r\n      where: { id: zoneId },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username: true,\r\n            email: true,\r\n            role: true,\r\n            department: true,\r\n            createdAt: true,\r\n            profile: { select: { image: true, tel: true, name: true } },\r\n          },\r\n        },\r\n        itemZones: {\r\n          include: {\r\n            results: {\r\n              include: {\r\n                defects: {\r\n                  where: {\r\n                    startTime: dateFilter\r\n                  },\r\n                  include: {\r\n                    user: {\r\n                      select: {\r\n                        id: true,\r\n                        role: true,\r\n                        email: true,\r\n                        username: true,\r\n                        profile: {\r\n                          select: {\r\n                            name: true,\r\n                            image: true,\r\n                            tel: true\r\n\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                },\r\n                comments: {\r\n                  where: {\r\n                    timestamp: dateFilter\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n    })\r\n\r\n    const allData = await prisma.zone.findUnique({\r\n      where: { id: zoneId },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username: true,\r\n            email: true,\r\n            role: true,\r\n            department: true,\r\n            createdAt: true,\r\n            profile: { select: { image: true, tel: true, name: true } },\r\n          },\r\n        },\r\n        itemZones: {\r\n          include: {\r\n            results: {\r\n              include: {\r\n                defects: true,\r\n                comments: true\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n    })\r\n\r\n    if (!zoneWithData || !allData) {\r\n      res.status(404).json({\r\n        message: \"Zone not found\"\r\n      })\r\n      return\r\n    }\r\n\r\n    let defectReported = 0\r\n    let defectCompleted = 0\r\n    let defectPending = 0\r\n    let monthlyDefects: { [key: string]: number } = {};\r\n    let allDefects: any[] = [];\r\n\r\n    for (const itemZone of zoneWithData.itemZones) {\r\n      for (const result of itemZone.results) {\r\n        defectReported += result.defects?.length || 0\r\n        for (const defect of result.defects) {\r\n          allDefects.push(defect);\r\n          if (defect.status === \"completed\") {\r\n            defectCompleted++;\r\n          } else {\r\n            defectPending++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const itemZone of allData.itemZones) {\r\n      for (const result of itemZone.results) {\r\n        for (const defect of result.defects) {\r\n          const defectDate = new Date(defect.startTime);\r\n          const defectMonth = defectDate.toLocaleString(\"en-US\", { month: \"long\" });\r\n          const defectYear = defectDate.getFullYear(); // ดึงปี\r\n          const monthYearKey = `${defectMonth} ${defectYear}`; // รวมเดือนและปี\r\n          monthlyDefects[monthYearKey] = (monthlyDefects[monthYearKey] || 0) + 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // กรองตาม status\r\n    if (status) {\r\n      allDefects = allDefects.filter(defect => defect.status === status);\r\n    }\r\n\r\n    // กรองตาม type (รองรับหลายค่า)\r\n    if (type) {\r\n      const types = (type as string).split(',');\r\n      allDefects = allDefects.filter(defect => types.includes(defect.type));\r\n    }\r\n\r\n    // กรองตาม search (รองรับหลายเงื่อนไข)\r\n    if (search) {\r\n      const searchId = parseInt(search as string, 10);\r\n      const mappedStatus = mapSearchToStatus(search as string);\r\n      const mappedType = mapSearchToType(search as string);\r\n\r\n      allDefects = allDefects.filter(defect => {\r\n        const searchLower = search.toString().toLocaleLowerCase();\r\n        const matchesId = defect.id === searchId;\r\n        const matchesStatus = mappedStatus ? defect.status === mappedStatus : false;\r\n        const matchesType = mappedType ? defect.type === mappedType : false;\r\n        const matchesName = defect.name?.toLowerCase().includes(searchLower);\r\n        const matchesUserName = defect.user?.profile?.name?.toLowerCase().includes(searchLower);\r\n\r\n        return matchesId || matchesStatus || matchesType || matchesName || matchesUserName;\r\n      });\r\n    }\r\n\r\n    // แปลง `endDate` เป็น Date Object\r\n    const endDateObj = endDate ? new Date(endDate as string) : null;\r\n    const endYear = endDateObj ? endDateObj.getFullYear() : null;\r\n    const endMonth = endDateObj ? endDateObj.getMonth() : null;\r\n\r\n    // สร้าง `chartData` และกรองข้อมูลตาม `endDate`\r\n    const chartData = Object.keys(monthlyDefects)\r\n      .map((monthYear) => {\r\n        const [monthName, year] = monthYear.split(\" \");\r\n        const monthIndex = new Date(`${monthName} 1, ${year}`).getMonth(); // แปลงชื่อเดือนเป็น index\r\n\r\n        return {\r\n          month: monthYear,\r\n          defect: monthlyDefects[monthYear],\r\n          year: parseInt(year),\r\n          monthIndex,\r\n        };\r\n      })\r\n      .filter((data) => {\r\n        // ถ้ามี `endDate` ให้กรองเฉพาะข้อมูลที่อยู่ก่อนหรือเท่ากับ `endDate`\r\n        if (endDateObj && endYear !== null && endMonth !== null) {\r\n          return data.year < endYear || (data.year === endYear && data.monthIndex <= endMonth);\r\n        }\r\n        return true;\r\n      })\r\n      .map(({ month, defect }) => ({ month, defect })); // คืนค่าเฉพาะฟิลด์ที่ต้องการ\r\n\r\n\r\n    const { itemZones, ...zoneWithoutItemZones } = zoneWithData\r\n\r\n    // คำนวณ trend\r\n    const currentMonthStart = startDate ? new Date(startDate as string) : new Date();\r\n    currentMonthStart.setDate(1);\r\n    currentMonthStart.setHours(0, 0, 0, 0);\r\n\r\n    const currentMonthEnd = new Date(currentMonthStart);\r\n    currentMonthEnd.setMonth(currentMonthEnd.getMonth() + 1);\r\n    currentMonthEnd.setMilliseconds(-1);\r\n\r\n    const previousMonthStart = new Date(currentMonthStart);\r\n    previousMonthStart.setMonth(previousMonthStart.getMonth() - 1);\r\n\r\n    const previousMonthEnd = new Date(currentMonthStart);\r\n    previousMonthEnd.setMilliseconds(-1);\r\n\r\n    const currentMonthData = await prisma.zone.findUnique({\r\n      where: { id: zoneId },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username: true,\r\n            email: true,\r\n            role: true,\r\n            department: true,\r\n            createdAt: true,\r\n            profile: { select: { image: true, tel: true, name: true } },\r\n          },\r\n        },\r\n        itemZones: {\r\n          include: {\r\n            results: {\r\n              include: {\r\n                defects: {\r\n                  where: {\r\n                    startTime: {\r\n                      gte: currentMonthStart,\r\n                      lte: currentMonthEnd,\r\n                    }\r\n                  }\r\n                },\r\n                comments: {\r\n                  where: {\r\n                    timestamp: {\r\n                      gte: currentMonthStart,\r\n                      lte: currentMonthEnd,\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n    })\r\n    const previousMonthData = await prisma.zone.findUnique({\r\n      where: { id: zoneId },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username: true,\r\n            email: true,\r\n            role: true,\r\n            department: true,\r\n            createdAt: true,\r\n            profile: { select: { image: true, tel: true, name: true } },\r\n          },\r\n        },\r\n        itemZones: {\r\n          include: {\r\n            results: {\r\n              include: {\r\n                defects: {\r\n                  where: {\r\n                    startTime: {\r\n                      gte: previousMonthStart,\r\n                      lte: previousMonthEnd,\r\n                    }\r\n                  }\r\n                },\r\n                comments: {\r\n                  where: {\r\n                    timestamp: {\r\n                      gte: previousMonthStart,\r\n                      lte: previousMonthEnd,\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n    })\r\n\r\n    if (!currentMonthData || !previousMonthData) {\r\n      res.status(404).send('Not Found Data')\r\n      return\r\n    }\r\n\r\n    let currentDefects = 0\r\n    let currentCompleted = 0\r\n    let currentPending = 0\r\n\r\n    let prevDefects = 0\r\n    let prevCompleted = 0\r\n    let prevPending = 0\r\n\r\n    for (const itemZone of currentMonthData.itemZones) {\r\n      for (const result of itemZone.results) {\r\n        currentDefects += result.defects?.length || 0\r\n        for (const defect of result.defects) {\r\n          defect.status === 'completed'\r\n            ? currentCompleted++\r\n            : currentPending++\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const itemZone of previousMonthData.itemZones) {\r\n      for (const result of itemZone.results) {\r\n        prevDefects += result.defects?.length || 0\r\n        for (const defect of result.defects) {\r\n          defect.status === 'completed'\r\n            ? prevCompleted++\r\n            : prevPending++\r\n        }\r\n      }\r\n    }\r\n\r\n    const result = {\r\n      ...zoneWithoutItemZones,\r\n      dashboard: {\r\n        defectReported: { value: defectReported, trend: calculateTrend(currentDefects, prevDefects) },\r\n        defectCompleted: { value: defectCompleted, trend: calculateTrend(currentCompleted, prevCompleted) },\r\n        defectPending: { value: defectPending, trend: calculateTrend(currentPending, prevPending) },\r\n        chartData,\r\n        defectTrend: calculateTrend(currentDefects, prevDefects),\r\n        defects: allDefects\r\n      }\r\n    }\r\n\r\n    res.status(200).json(result)\r\n    return\r\n\r\n  } catch (error) {\r\n    console.error(\"Server Error:\", error)\r\n    res.status(500).json(\"Internal server error\")\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล ZoneSs ทั้งหมด\r\n * Input: -\r\n * Output: JSON object ข้อมูล Zone\r\n **/\r\nexport async function getAllZones(req: Request, res: Response) {\r\n  try {\r\n    const zone = await prisma.zone.findMany({\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n      },\r\n    });\r\n    if (!zone) {\r\n      res.status(404);\r\n      return;\r\n    }\r\n    let result = zone;\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error)\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูล Location\r\n * Input:\r\n * - req.params.id: Int (ID ของ Location)\r\n * Output: JSON object ข้อมูล Location\r\n **/\r\nexport async function getLocation(req: Request, res: Response) {\r\n  try {\r\n    const id = parseInt(req.params.id, 10);\r\n    const location = await prisma.location.findUnique({\r\n      where: { id: id },\r\n      include: {\r\n        zones: {\r\n          include: {\r\n            supervisor: {\r\n              select: {\r\n                id: true,\r\n                username: true,\r\n                email: true,\r\n                role: true,\r\n                department: true,\r\n                createdAt: true,\r\n                profile: { select: { image: true, tel: true, name: true } },\r\n\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!location) {\r\n      res.status(404);\r\n      return;\r\n    }\r\n\r\n    let result = location;\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error)\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับเปลี่ยน Supervisor\r\n * Input:\r\n * - req.params.id: number (ID ของ Zone ที่ต้องการเปลี่ยน Supervisor)\r\n * - req.body: { userId: number},\r\n * Output: JSON object ข้อมูล Zone หลังจาก update\r\n **/\r\nexport async function updateSupervisor(req: Request, res: Response) {\r\n  try {\r\n    const zoneId = parseInt(req.params.id, 10);\r\n    const { userId } = req.body;\r\n\r\n    const oldZone = await prisma.zone.findUnique({\r\n      where: { userId: userId },\r\n    });\r\n\r\n    if (oldZone && oldZone.id !== zoneId) {\r\n      await prisma.zone.update({\r\n        where: { id: oldZone.id },\r\n        data: { userId: null },\r\n      });\r\n    }\r\n\r\n    // อัปเดต zone\r\n    await prisma.zone.update({\r\n      where: { id: zoneId },\r\n      data: {\r\n        userId: userId ? parseInt(userId, 10) : null,\r\n      },\r\n    });\r\n\r\n    let result = await prisma.zone.findUnique({\r\n      where: {\r\n        id: zoneId,\r\n      },\r\n      include: {\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            username: true,\r\n            email: true,\r\n            role: true,\r\n            department: true,\r\n            createdAt: true,\r\n            profile: { select: { image: true, tel: true, name: true } },\r\n\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const message = `update_supervisor-${result?.name}`;\r\n    await createNotification({\r\n      message: message,\r\n      type: \"information\" as NotificationType,\r\n      url: `/profile`,\r\n      userId: userId,\r\n    });\r\n\r\n    res.status(200).json(result);\r\n    return;\r\n  } catch (error) {\r\n    console.error(error)\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\patrol-controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\preset-controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\user-controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Controllers\\util-controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":230,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":230,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":703,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":703,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import bcrypt from \"bcryptjs\";\r\nimport prisma from \"@Utils/database.js\";\r\nimport { NextFunction, Request, Response } from \"express\";\r\nimport jwt, { JwtPayload } from 'jsonwebtoken';\r\nimport multer from 'multer';\r\nimport { getIOInstance } from '@Utils/socket.js';\r\nimport nodemailer from 'nodemailer';\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport { DefectStatus } from \"@prisma/client\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { randomBytes } from 'node:crypto';\r\n\r\ndeclare global {\r\n  namespace Express {\r\n    interface Request {\r\n      user?: string | JwtPayload;\r\n    }\r\n  }\r\n}\r\n\r\n// Generate a JWT token and set it as a cookie with an expiration time\r\nconst jwtSecret = process.env.JWT_SECRET || \"defaultSecretKey\";\r\nconst jwtRefreshSecret = process.env.JWT_REFRESH_SECRET || \"refreshSecretKey\";\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับ login เข้าสู่ระบบ\r\n * Input: \r\n * - req.body: { username: String, password: String, rememberMe: Boolean}\r\n * Output: JSON message ยืนยันการ login สำเร็จ\r\n**/\r\nexport async function login(req: Request, res: Response) {\r\n  const { username, password, rememberMe } = req.body;\r\n  try {\r\n    // Find the user by username\r\n    const user = await prisma.user.findUnique({\r\n      where: { username: username },\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(401).json({ message: \"Invalid username\" });\r\n      return;\r\n    }\r\n\r\n    // Compare the provided password with the hashed password in the database\r\n    const passwordMatch = await bcrypt.compare(password, user.password);\r\n\r\n    if (!passwordMatch) {\r\n      res.status(401).json({ message: \"Invalid password\" });\r\n      return;\r\n    }\r\n\r\n    if (!user.active) {\r\n      res.status(403).json({ message: \"Your account is inactive. Please contact support.\" });\r\n      return;\r\n    }\r\n\r\n    await prisma.session.deleteMany({ where: { userId: user.id } });\r\n    const sessionId = uuidv4();\r\n    const expiresAt = new Date(Date.now() + (rememberMe ? 30 * 24 * 60 * 60 * 1000 : 1 * 60 * 60 * 1000));\r\n    await prisma.session.create({\r\n      data: {\r\n        userId: user.id,\r\n        token: sessionId,\r\n        expiresAt: expiresAt,\r\n      },\r\n    });\r\n\r\n    const accessToken = jwt.sign({ userId: user.id, role: user.role, sessionId }, jwtSecret, { expiresIn: \"1h\" });\r\n    const refreshToken = jwt.sign({ userId: user.id, role: user.role, sessionId }, jwtRefreshSecret, { expiresIn: \"7d\" });\r\n\r\n    res.cookie(\"authToken\", accessToken, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === \"production\" ? true : false,\r\n      sameSite: process.env.NODE_ENV === \"production\" ? 'none' : 'lax',\r\n      maxAge: 60 * 60 * 1000,\r\n    });\r\n\r\n    res.cookie(\"refreshToken\", refreshToken, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === \"production\" ? true : false,\r\n      sameSite: process.env.NODE_ENV === \"production\" ? 'none' : 'lax',\r\n      maxAge: 7 * 24 * 60 * 60 * 1000,\r\n    });\r\n\r\n    res.status(200).json({ message: \"Login Success\", accessToken, refreshToken });\r\n    return\r\n  } catch (error) {\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับ logout ออกจากระบบ\r\n * Input: \r\n * - req.cookies.authToken: String (Token ของผู้ใช้งานที่ใช้สำหรับการยืนยันตัวตน) \r\n * Output: JSON message ยืนยันการ logout สำเร็จ\r\n**/\r\nexport async function logout(req: Request, res: Response) {\r\n  try {\r\n    const token = req.cookies.authToken;\r\n\r\n    if (!token) {\r\n      res.status(200).json({ message: \"Already logged out\" });\r\n      return\r\n    }\r\n\r\n    // ตรวจสอบ JWT Token\r\n    const decoded: any = jwt.verify(token, jwtSecret);\r\n\r\n    // ลบ session ออกจากฐานข้อมูล\r\n    await prisma.session.deleteMany({ where: { userId: decoded.userId } });\r\n\r\n    // Clear the cookie named \"authToken\"\r\n    res.clearCookie(\"authToken\", {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === \"production\" ? true : false,\r\n      sameSite: process.env.NODE_ENV === \"production\" ? 'none' : 'lax'\r\n    });\r\n    res.clearCookie(\"refreshToken\", {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === \"production\" ? true : false,\r\n      sameSite: process.env.NODE_ENV === \"production\" ? 'none' : 'lax'\r\n    });\r\n    res.status(200).json({ message: \"Logout successful\" });\r\n    return\r\n  } catch (error) {\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับตรวจสอบการยืนยันตัวตนของผู้ใช้งาน (Authentication)\r\n * Input: \r\n * - req.cookies.authToken: String (Token ของผู้ใช้งานที่ใช้สำหรับการยืนยันตัวตน) \r\n * Output: \r\n * - ถ้า Token ถูกต้อง: ส่งต่อการทำงานไปยังฟังก์ชันถัดไป (next middleware)\r\n * - ถ้า TOken ไม่ถูกต้อง: JSON message แจ้งเตือนข้อผิดพลาด เช่น \"Access Denied\" หรือ \"Invalid Token\"\r\n**/\r\nexport async function authenticateUser(req: Request, res: Response, next: NextFunction) {\r\n  const token = req.cookies.authToken;\r\n\r\n  if (!token) {\r\n    res.status(401).json({ status: 401, message: \"Access Denied, No Token Provided\" });\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const decoded = jwt.verify(token, jwtSecret) as JwtPayload;\r\n\r\n    const session = await prisma.session.findUnique({\r\n      where: { userId: decoded.userId },\r\n    });\r\n\r\n    if (!session || session.token !== decoded.sessionId) {\r\n      res.clearCookie(\"authToken\");\r\n      res.clearCookie(\"refreshToken\");\r\n      res.status(401).json({ message: \"Session expired\" });\r\n      return\r\n    }\r\n\r\n    // เพิ่มตรวจสอบเวลา Session หมดอายุ\r\n    if (session && new Date() > session.expiresAt) {\r\n      await prisma.session.delete({ where: { id: session.id } });\r\n      res.clearCookie(\"authToken\");\r\n      res.clearCookie(\"refreshToken\");\r\n      res.status(401).json({ message: \"Session expired\" });\r\n      return\r\n    }\r\n\r\n    req.user = decoded;\r\n    next();\r\n  } catch (error) {\r\n    res.status(400).json({ message: \"Invalid Token\", error })\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับรีเฟรช Access Token โดยตรวจสอบ Refresh Token และสถานะเซสชันของผู้ใช้\r\n * Input: \r\n * - req.cookies.refreshToken: String (Refresh Token ของผู้ใช้ที่ใช้สำหรับออก Access Token ใหม่)\r\n * Output: \r\n * - ถ้า Refresh Token ถูกต้องและเซสชันยังคงอยู่: คืนค่า Access Token ใหม่\r\n * - ถ้า Refresh Token ไม่ถูกต้อง หรือเซสชันหมดอายุ: คืนค่า JSON message แจ้งเตือน เช่น \"Session expired\" หรือ \"Invalid refresh token\"\r\n **/\r\nexport async function refreshToken(req: Request, res: Response) {\r\n  const refreshToken = req.cookies.refreshToken;\r\n  if (!refreshToken) {\r\n    res.status(401).json({ message: \"No refresh token provided\" });\r\n  }\r\n\r\n  try {\r\n    const decoded: any = jwt.verify(refreshToken, jwtRefreshSecret);\r\n\r\n    // ตรวจสอบ session ใน MySQL\r\n    const session = await prisma.session.findUnique({ where: { userId: decoded.userId } });\r\n\r\n    if (!session || session.token !== decoded.sessionId) {\r\n      res.clearCookie(\"authToken\");\r\n      res.clearCookie(\"refreshToken\");\r\n      res.status(401).json({ message: \"Session expired, please login again\" });\r\n      return\r\n    }\r\n    if (new Date() > session.expiresAt) {\r\n      await prisma.session.delete({ where: { id: session.id } });\r\n      res.clearCookie(\"authToken\");\r\n      res.clearCookie(\"refreshToken\");\r\n      res.status(401).json({ message: \"Session expired\" });\r\n      return\r\n    }\r\n\r\n    const user = await prisma.user.findUnique({ where: { id: decoded.userId } });\r\n\r\n    // สร้าง accessToken ใหม่\r\n    const newAccessToken = jwt.sign({ userId: decoded.userId, role: user?.role, sessionId: decoded.sessionId }, jwtSecret, {\r\n      expiresIn: \"1h\",\r\n    });\r\n\r\n    res.cookie(\"authToken\", newAccessToken, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === \"production\" ? true : false,\r\n      sameSite: process.env.NODE_ENV === \"production\" ? 'none' : 'lax',\r\n      maxAge: 60 * 60 * 1000, // 1 ชั่วโมง\r\n    });\r\n\r\n    res.status(200).json({ accessToken: newAccessToken });\r\n    return\r\n  } catch (error) {\r\n    res.status(403).json({ message: \"Invalid refresh token\" });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อมูลการแจ้งเตือน\r\n * Input: \r\n * - (req as any).user.userId : Int (Id ของผู้ใช้ที่กำลังล็อคอิน)\r\n * Output: JSON message ของ notification  \r\n**/\r\nexport async function getAllNotifications(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n\r\n    const notifications = await prisma.notification.findMany({\r\n      where: { userId: userId },\r\n      orderBy: { timestamp: 'desc' },\r\n    });\r\n    let result = notifications;\r\n\r\n    res.status(200).json(result);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับสร้างการแจ้งเตือน\r\n * Input: \r\n * - req.body: { message: string, type: NotificationType, url: String | Null, userId: Int }\r\n * Output: JSON object ของ notification ที่ถูกสร้าง รวมถึงข้อมูลที่เกี่ยวข้อง \r\n**/\r\nexport async function createNotification({ message, type, url, userId }: any) {\r\n  try {\r\n    const notification = await prisma.notification.create({\r\n      data: {\r\n        message,\r\n        timestamp: new Date(),\r\n        type,\r\n        url,\r\n        read: false,\r\n        userId,\r\n      },\r\n    });\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: userId },\r\n      select: { email: true },\r\n    });\r\n\r\n    // Send an email notification if the user's email exists\r\n    if (user?.email && isEmailNotificationRequired(message)) {\r\n      const emailSubject = getEmailSubject(message);\r\n      const emailMessage = getNotificationMessage(message, url);\r\n\r\n      await sendEmail(user.email, emailSubject, emailMessage);\r\n    }\r\n\r\n    let result = notification;\r\n\r\n    // Emit an event to notify the client in real-time\r\n    const io = getIOInstance();\r\n    io.to(`notif_${userId}`).emit('new_notification', result);\r\n\r\n    return notification;\r\n  } catch (error) {\r\n    console.error(\"Error creating notification\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงหัวข้ออีเมลตามประเภทของการแจ้งเตือน\r\n * Input: \r\n * - message: string (ข้อความที่ระบุประเภทของการแจ้งเตือน เช่น 'report_defect', 'defect_completed', หรือ 'defect_pending_inspection')\r\n * Output: \r\n * - string (หัวข้ออีเมลที่เกี่ยวข้องกับประเภทของการแจ้งเตือน)\r\n */\r\nfunction getEmailSubject(message: string): string {\r\n  const subjects: Record<string, string> = {\r\n    \"report_defect\": \"New Defect Reported - Immediate Action Required\",\r\n    \"defect_completed\": \"Defect Resolved - Inspection Passed\",\r\n    \"defect_pending_inspection\": \"Defect Rework Required - Previous Fix Not Approved\",\r\n  };\r\n\r\n  return subjects[message] || \"New Notification\";\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับตรวจสอบว่าอีเมลควรถูกส่งหรือไม่ตามประเภทของการแจ้งเตือน\r\n * Input: \r\n * - message: string (ประเภทของการแจ้งเตือน เช่น 'defect_completed', 'defect_pending_inspection', หรือ 'report_defect')\r\n * Output: \r\n * - boolean (ค่าคืนที่เป็น true หากอีเมลควรถูกส่ง, false หากไม่ควรส่ง)\r\n */\r\nfunction isEmailNotificationRequired(message: string): boolean {\r\n  return [\"defect_completed\", \"defect_pending_inspection\", \"report_defect\"].includes(message);\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับดึงข้อความแจ้งเตือนตามประเภทของการแจ้งเตือน\r\n * Input: \r\n * - message: string (ประเภทของการแจ้งเตือน เช่น 'report_defect', 'defect_completed', หรือ 'defect_pending_inspection')\r\n * - url: string (URL สำหรับการเข้าถึงข้อมูลเพิ่มเติม)\r\n * Output: \r\n * - string (ข้อความแจ้งเตือนที่รวมทั้งภาษาอังกฤษและภาษาไทย พร้อมลิงก์เพื่อเชื่อมต่อ)\r\n */\r\nfunction getNotificationMessage(message: string, url: string): string {\r\n  const messages: Record<string, { en: string; th: string }> = {\r\n    \"report_defect\": {\r\n      en: \"An issue has been reported in your assigned zone. Please check immediately.\",\r\n      th: \"มีการแจ้งปัญหาในโซนที่คุณรับผิดชอบ กรุณาตรวจสอบทันที\",\r\n    },\r\n    \"defect_completed\": {\r\n      en: \"The defect has been successfully resolved. Please review the completed work.\",\r\n      th: \"ปัญหาได้รับการแก้ไขเสร็จสมบูรณ์แล้ว กรุณาตรวจสอบผลการแก้ไข\",\r\n    },\r\n    \"defect_pending_inspection\": {\r\n      en: \"The defect has not been approved. Please revise and resubmit for inspection.\",\r\n      th: \"ปัญหายังไม่ได้รับการอนุมัติ กรุณาดำเนินการแก้ไขและส่งตรวจใหม่\",\r\n    },\r\n  };\r\n\r\n  const selectedMessage = messages[message];\r\n  if (!selectedMessage) return \"You have a new notification.\";\r\n\r\n  return `\r\n  ${selectedMessage.en}<br><br>\r\n  Check it here: ${process.env.CLIENT_URL}/en${url}<br><br>\r\n  <hr><br><br>\r\n  ${selectedMessage.th}<br><br>\r\n  คลิกที่นี่: ${process.env.CLIENT_URL}/th${url}\r\n`;\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดตสถานะการแจ้งเตือนให้เป็น \"อ่านแล้ว\"\r\n * Input: \r\n * - req.params: { id: int } (ID ของการแจ้งเตือนที่ต้องการอัปเดต)\r\n * Output: JSON object ของการแจ้งเตือนที่ถูกอัปเดต \r\n**/\r\nexport async function updateNotification(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n    const notification = await prisma.notification.update({\r\n      where: { id: parseInt(id, 10) },\r\n      data: { read: true },\r\n    });\r\n    res.status(200).json(notification);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับเปลี่ยนสถานะการแจ้งเตือนทั้งหมดของผู้ใช้ให้เป็น \"อ่านแล้ว\"\r\n * Input: \r\n * - req.user.userId: int (ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: \r\n * - JSON message ยืนยันการเปลี่ยนสถานะการแจ้งเตือนสำเร็จ\r\n**/\r\nexport async function markAllAsRead(req: Request, res: Response) {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    await prisma.notification.updateMany({\r\n      where: { userId: userId, read: false },\r\n      data: { read: true },\r\n    });\r\n    res.status(200).json({ message: \"All notifications marked as read\" });\r\n  } catch (error) {\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับเปลี่ยนสถานะการแจ้งเตือนให้เป็น \"อ่านแล้ว\"\r\n * Input:\r\n * - req.params.id: String (ID ของการแจ้งเตือนที่ต้องการเปลี่ยนสถานะ)\r\n * Output:\r\n * - ถ้าพบการแจ้งเตือนที่ยังไม่ได้อ่าน: อัปเดตสถานะเป็น \"อ่านแล้ว\" และคืนค่า JSON message \"Notification marked as read\"\r\n * - ถ้าไม่พบการแจ้งเตือนที่ยังไม่ได้อ่าน: คืนค่า JSON message \"No unread notifications found\"\r\n * - ถ้ามีข้อผิดพลาดเกิดขึ้น: คืนค่า JSON message \"Internal server error\"\r\n **/\r\nexport async function markAsRead(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n\r\n    // Check if the notification exists and is unread\r\n    const notification = await prisma.notification.findFirst({\r\n      where: {\r\n        id: parseInt(id),\r\n        read: false,\r\n      },\r\n    });\r\n\r\n    if (!notification) {\r\n      return res.status(404).json({ message: \"No unread notifications found\" });\r\n    }\r\n\r\n    // Update the notification to mark it as read\r\n    await prisma.notification.update({\r\n      where: { id: parseInt(id) },\r\n      data: { read: true },\r\n    });\r\n\r\n    res.status(200).json({ message: \"Notification marked as read\" });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: `Internal server error: ${error}` });\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบการแจ้งเตือนที่มีอายุเกิน 7 วัน\r\n * Input: \r\n * - ไม่มี Input\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะลบการแจ้งเตือนเก่าจากฐานข้อมูล\r\n**/\r\nexport async function removeOldNotifications() {\r\n  try {\r\n    const sevenDaysAgo = new Date();\r\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\r\n\r\n    await prisma.notification.deleteMany({\r\n      where: {\r\n        timestamp: {\r\n          lt: sevenDaysAgo,\r\n        },\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error deleting old notifications:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบการแจ้งเตือนที่ต้องการ\r\n * Input: \r\n * - req.param = id\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะลบการแจ้งเตือนออกจากฐานข้อมูล\r\n**/\r\nexport async function removeNotification(req: Request, res: Response) {\r\n  try {\r\n    const { id } = req.params;\r\n    await prisma.notification.delete({\r\n      where: {\r\n        id: parseInt(id),\r\n      },\r\n    });\r\n    res.status(200)\r\n    return\r\n  } catch (error) {\r\n    console.error(\"Error deleting notification:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบการแจ้งเตือนที่ต้องการ\r\n * Input: \r\n * - req.user: { userId: number } (บทบาทและ ID ของผู้ใช้งานที่กำลังล็อกอิน)\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะลบการแจ้งเตือนทั้งหมดของผู้ใช้ออกจากฐานข้อมูล\r\n**/\r\nexport async function removeAllNotifications(req: Request, res: Response) {\r\n  const userId = (req as any).user.userId;\r\n  try {\r\n    await prisma.notification.deleteMany({\r\n      where: {\r\n        userId: userId,\r\n      },\r\n    });\r\n    res.status(200)\r\n    return\r\n  } catch (error) {\r\n    console.error(\"Error deleting notification:\", error);\r\n  }\r\n}\r\n\r\n// Nodemailer transporter for sending emails\r\nconst transporter = nodemailer.createTransport({\r\n  service: 'gmail',\r\n  auth: {\r\n    user: process.env.EMAIL_USER,\r\n    pass: process.env.EMAIL_PASSWORD,\r\n  },\r\n});\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับส่งอีเมลโดยใช้ nodemailer\r\n * Input: \r\n * - email: String (อีเมลผู้รับ)\r\n * - subject: String (หัวข้อของอีเมล)\r\n * - message: String (ข้อความในเนื้อหาอีเมล)\r\n * Output: \r\n * - ไม่มี Output ที่ส่งกลับ แต่จะทำการส่งอีเมล\r\n**/\r\nexport async function sendEmail(email: string, subject: string, message: string) {\r\n  try {\r\n    const logoUrl = \"https://drive.google.com/uc?export=view&id=1DpK74AifxmbKcDjZQ7KM0_Qnu1svq3Oi\"\r\n\r\n    const htmlMessage = `\r\n      <html>\r\n        <body style=\"text-align: center; font-family: Arial, sans-serif;\">\r\n          <div style=\"margin-bottom: 20px;\">\r\n            <img src=\"${logoUrl}\" alt=\"Logo\" style=\"max-width: 200px;\"/>\r\n          </div>\r\n          \r\n          <div>\r\n            <p>${message}</p>\r\n          </div>\r\n        </body>\r\n      </html>\r\n    `;\r\n\r\n    await transporter.sendMail({\r\n      from: process.env.EMAIL_USER,\r\n      to: email,\r\n      subject: subject,\r\n      text: message,\r\n      html: htmlMessage\r\n    });\r\n  } catch (error) {\r\n    console.error('Error sending email:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับตรวจสอบสิทธิ์การเข้าถึง\r\n * Input: \r\n * - allowedRoles: string[] (role ที่อณุญาติให้เข้าถึงข้อมูล)\r\n * Output: \r\n * - ทำ Function  ต่อไป\r\n**/\r\nexport function authorized(allowedRoles: string[]) {\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    const userRole = (req as any).user.role;\r\n\r\n    if (!allowedRoles.includes(userRole)) {\r\n      res.status(403).json({ message: `Access Denied: Required roles are ${allowedRoles.join(\", \")}` });\r\n      return;\r\n    }\r\n    next();\r\n  };\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับคำนวณ Trend เป็นเปอร์เซ็นต์\r\n * Input:\r\n * - current: number (ค่าปัจจุบัน)\r\n * - previous: number (ค่าก่อนหน้า)\r\n * Output:\r\n * - ค่าร้อยละของการเปลี่ยนแปลงระหว่างค่าปัจจุบันและค่าก่อนหน้า\r\n * - ถ้า previous เป็น 0:\r\n *   - คืนค่า 100 ถ้า current มากกว่า 0 (แสดงการเพิ่มขึ้นเต็มที่)\r\n *   - คืนค่า 0 ถ้า current เท่ากับ 0 (ไม่มีการเปลี่ยนแปลง)\r\n **/\r\nexport const calculateTrend = (current: number, previous: number): number => {\r\n  if (previous === 0) return current > 0 ? 100 : 0;\r\n  return Number((((current - previous) / previous) * 100).toFixed(2));\r\n};\r\n\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับกำหนดการจัดเก็บไฟล์อัปโหลดโดยใช้ multer\r\n * Input: \r\n * - req.file: Object (ไฟล์รูปภาพที่อัปโหลด โดย multer จะจัดเก็บลงใน `uploads/profiles/{userId}/`)\r\n * - req.user.userId: Number (ID ของผู้ใช้ ใช้กำหนดโฟลเดอร์และชื่อไฟล์)\r\n * Output: \r\n * - ไฟล์ที่อัปโหลดจะถูกจัดเก็บใน `uploads/profiles/{userId}/` \r\n * - req.file: Object (รายละเอียดของไฟล์ เช่น ชื่อไฟล์, ขนาดไฟล์, และประเภทของไฟล์)\r\n **/\r\nconst profileStorage = multer.diskStorage({\r\n  destination: (req, file, callback) => {\r\n    const userId = (req as any).user.userId;\r\n    const folderPath = path.join('uploads', 'profiles', userId.toString());\r\n\r\n    fs.mkdirSync(folderPath, { recursive: true });\r\n    callback(null, folderPath);\r\n  },\r\n  filename: (req, file, callback) => {\r\n    const userId = (req as any).user.userId;\r\n    const timestamp = new Date().toISOString().replace(/[-:.]/g, '');\r\n    const uniqueSuffix = `${userId}_${timestamp}_${file.originalname}`;\r\n    callback(null, uniqueSuffix);\r\n  },\r\n});\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับกำหนดการจัดเก็บไฟล์อัปโหลดของ defect โดยใช้ multer\r\n * Input: \r\n * - req.params.id: String (ID ของ defect ที่ใช้กำหนดโฟลเดอร์จัดเก็บ)\r\n * - req.body.status: String (สถานะของ defect ใช้ระบุโฟลเดอร์ย่อย เช่น 'reported' หรือสถานะอื่น ๆ)\r\n * - req.file: Object (ไฟล์รูปภาพ defect ที่อัปโหลด)\r\n * Output: \r\n * - ไฟล์ที่อัปโหลดจะถูกจัดเก็บใน `uploads/defects/{id}/{folderType}/`\r\n *   - `{folderType}` จะเป็น `before` ถ้าสถานะเป็น 'reported' และเป็น `after` สำหรับสถานะอื่น ๆ\r\n * - req.file: Object (รายละเอียดของไฟล์ เช่น ชื่อไฟล์, ขนาดไฟล์, และประเภทของไฟล์)\r\n **/\r\nconst defectStorage = multer.diskStorage({\r\n  destination: (req, file, callback) => {\r\n    const id = req.params.id;\r\n    const status = req.body.status;\r\n\r\n    if (!id || !status) {\r\n      return callback(new Error(\"defectId and status are required\"), \"\");\r\n    }\r\n\r\n    const folderType = status === 'reported' ? 'before' : 'after';\r\n    // ปรับโครงสร้างโฟลเดอร์ที่ต้องการให้เป็น uploads/defects/id/folderType\r\n    const folderPath = path.join('uploads', 'defects', id.toString(), folderType);\r\n\r\n    fs.mkdirSync(folderPath, { recursive: true });\r\n    callback(null, folderPath);\r\n  },\r\n  filename: (req, file, callback) => {\r\n    const id = req.params.id;\r\n    const timestamp = new Date().toISOString().replace(/[-:.]/g, '');\r\n    const uniqueSuffix = `${id}_${timestamp}_${file.originalname}`;\r\n    callback(null, uniqueSuffix);\r\n  },\r\n});\r\n\r\n// Export the multer upload middleware\r\nexport const profileUpload = multer({ storage: profileStorage });\r\nexport const defectUpload = multer({ storage: defectStorage });\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับคืนค่า path ของโฟลเดอร์ที่ใช้เก็บไฟล์อัปโหลด\r\n * Input: \r\n * - ไม่มีพารามิเตอร์รับเข้า\r\n * Output: \r\n * - String: เส้นทางของโฟลเดอร์ `uploads` โดยอ้างอิงจากตำแหน่งปัจจุบันของโปรเจกต์\r\n **/\r\nfunction getUploadsPath(): string {\r\n  const currentDir = process.cwd();\r\n  return path.join(currentDir, \"uploads\"); // Adjust path as needed\r\n}\r\n\r\nexport const uploadsPath = getUploadsPath();\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปโหลดรูปภาพของ defect และจัดเก็บไฟล์ในโฟลเดอร์ที่เหมาะสม\r\n * Input: \r\n * - req.params.id: String (รหัสของ defect ที่ต้องการอัปโหลดรูป)\r\n * - req.body.status: String (สถานะของ defect ที่ใช้กำหนดโฟลเดอร์ปลายทาง เช่น 'reported' หรือ 'resolved')\r\n * - req.files: Array<Express.Multer.File> (ไฟล์รูปภาพที่ถูกอัปโหลด)\r\n * - req.user.userId: String (รหัสผู้ใช้งานที่ทำการอัปโหลด)\r\n * Output: \r\n * - หากอัปโหลดสำเร็จ: JSON message `{ message: \"Files uploaded successfully\", images: [...] }`\r\n * - หากเกิดข้อผิดพลาด: JSON message `{ error: \"File upload failed\" }`\r\n **/\r\nexport const uploadDefectImages = async (req: Request, res: Response) => {\r\n  try {\r\n    const userId = (req as any).user.userId;\r\n    const { id } = req.params;\r\n    const { status } = req.body;\r\n    let images: any[] = [];\r\n\r\n    if (req.files) {\r\n      const imageFiles = req.files as Express.Multer.File[];\r\n      images = await handleDefectImagesUpload(\r\n        parseInt(id),\r\n        status as DefectStatus,\r\n        userId,\r\n        imageFiles\r\n      );\r\n    }\r\n\r\n    res.status(200).json({ message: \"Files uploaded successfully\", images: images, });\r\n  } catch (error) {\r\n    res.status(500).json({ error: \"File upload failed\" });\r\n  }\r\n};\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับจัดการการอัปโหลดรูปภาพของ defect และบันทึกข้อมูลลงฐานข้อมูล\r\n * Input: \r\n * - defectId: number (รหัสของ defect ที่ต้องการอัปโหลดรูป)\r\n * - status: DefectStatus (สถานะของ defect ที่ใช้กำหนดประเภทของโฟลเดอร์ เช่น 'reported' หรือ 'resolved')\r\n * - updatedBy: number (รหัสผู้ใช้งานที่ทำการอัปโหลด)\r\n * - files: Express.Multer.File[] (รายการไฟล์รูปภาพที่อัปโหลด)\r\n * Output: \r\n * - คืนค่ารายการรูปภาพที่ถูกสร้างขึ้น พร้อมข้อมูลที่เกี่ยวข้อง\r\n * - ข้อมูลรูปภาพถูกบันทึกในฐานข้อมูลตาราง `image` และมีการเชื่อมโยงกับ defect ในตาราง `defectImage`\r\n **/\r\nexport const handleDefectImagesUpload = async (\r\n  defectId: number,\r\n  status: DefectStatus,\r\n  updatedBy: number,\r\n  files: Express.Multer.File[]\r\n) => {\r\n  const createdImages: any[] = [];\r\n  for (const file of files) {\r\n    const folderType =\r\n      status === 'reported' ? 'before' : 'after';\r\n    // สร้าง folderPrefix ตามที่ได้กำหนดใน multer diskStorage\r\n    const folderPath = path.join('defects', defectId.toString(), folderType);\r\n\r\n    // ใช้ filename ที่ได้จาก multer diskStorage (filename ที่ใช้จะต้องอยู่ในโครงสร้างเดียวกัน)\r\n    const filePath = path.join(folderPath, file.filename);\r\n\r\n    const image = await prisma.image.create({\r\n      data: {\r\n        path: filePath,\r\n        updatedBy: updatedBy,\r\n        timestamp: new Date(),\r\n      },\r\n      include: {\r\n        user: {\r\n          select: {\r\n            id: true\r\n          }\r\n        },\r\n      }\r\n    });\r\n\r\n    await prisma.defectImage.create({\r\n      data: {\r\n        defectId: defectId,\r\n        imageId: image.id,\r\n      },\r\n    });\r\n    createdImages.push({ image });\r\n  }\r\n  return createdImages;\r\n};\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับจัดกลุ่มรูปภาพตาม timestamp โดยพิจารณาค่าความแตกต่างของเวลา\r\n * Input: \r\n * - images: Array<{ id, timestamp, updatedBy, path }> (อาร์เรย์ของรูปภาพที่มีข้อมูลเกี่ยวกับ id, timestamp, updatedBy และ path)\r\n * - thresholdMs: number (ค่าความแตกต่างของเวลาที่ใช้เป็นเกณฑ์ในการจัดกลุ่ม (หน่วยเป็นมิลลิวินาที))\r\n * Output: \r\n * - คืนค่าอาร์เรย์ของกลุ่มรูปภาพที่จัดกลุ่มตามเงื่อนไขของ thresholdMs\r\n * - รูปภาพที่มี timestamp ใกล้เคียงกันภายในช่วง thresholdMs จะถูกจัดอยู่ในกลุ่มเดียวกัน\r\n **/\r\nconst groupImagesByTimestamp = (\r\n  images: Array<{\r\n    id: number;\r\n    timestamp: Date;\r\n    updatedBy: number;\r\n    path: string;\r\n  }>,\r\n  thresholdMs: number\r\n) => {\r\n  if (images.length === 0) return [];\r\n\r\n  const groups: Array<Array<{\r\n    id: number;\r\n    timestamp: Date;\r\n    updatedBy: number;\r\n    path: string;\r\n  }>> = [];\r\n  let currentGroup = [images[0]];\r\n  let currentTime = images[0].timestamp.getTime();\r\n\r\n  for (let i = 1; i < images.length; i++) {\r\n    const imgTime = images[i].timestamp.getTime();\r\n    if (currentTime - imgTime <= thresholdMs) {\r\n      currentGroup.push(images[i]);\r\n    } else {\r\n      groups.push(currentGroup);\r\n      currentGroup = [images[i]];\r\n      currentTime = imgTime;\r\n    }\r\n  }\r\n  groups.push(currentGroup);\r\n  return groups;\r\n};\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับอัปเดตรูปภาพของ defect ตามสถานะที่กำหนด โดยรองรับการลบภาพเดิมและเพิ่มภาพใหม่\r\n * Input: \r\n * - defectId: number (รหัสของ defect)\r\n * - status: DefectStatus (สถานะของ defect ที่ใช้กำหนดเงื่อนไขการอัปเดตรูปภาพ)\r\n * - options: Object (ตัวเลือกเพิ่มเติม)\r\n *    - updatedBy: number (รหัสผู้ใช้ที่อัปเดต)\r\n *    - supervisorId?: number (รหัสของ supervisor กรณีที่ต้องการลบภาพของ supervisor)\r\n *    - deleteExistingImages?: boolean (ตัวเลือกเพื่อลบภาพเดิม หากเป็น true จะลบภาพเดิมตามเงื่อนไข)\r\n *    - files: Express.Multer.File[] (อาร์เรย์ของไฟล์ที่ต้องการอัปโหลด)\r\n * Output: \r\n * - ดำเนินการลบภาพเดิมตามเงื่อนไขที่กำหนด\r\n * - ดำเนินการอัปโหลดภาพใหม่และเชื่อมโยงกับ defect\r\n **/\r\nexport const handleDefectImagesUpdate = async (\r\n  defectId: number,\r\n  status: DefectStatus,\r\n  options: {\r\n    updatedBy: number;\r\n    supervisorId?: number;\r\n    deleteExistingImages?: boolean;\r\n    files: Express.Multer.File[];\r\n  }\r\n) => {\r\n  // ลบภาพเดิมตามเงื่อนไข\r\n  const existingDefectImages = await prisma.defectImage.findMany({\r\n    where: { defectId },\r\n    select: { imageId: true },\r\n  });\r\n\r\n  const existingImages = await prisma.image.findMany({\r\n    where: { id: { in: existingDefectImages.map((img) => img.imageId) } },\r\n    select: { id: true, path: true, updatedBy: true, timestamp: true },\r\n    orderBy: { timestamp: 'desc' },\r\n  });\r\n\r\n  // เงื่อนไขลบภาพเมื่ออัปเดต\r\n  if (status === 'reported') {\r\n    // ลบทั้งหมดเมื่อสถานะเป็น reported\r\n\r\n    await deleteImages(existingImages.map(img => img.id))\r\n  } else if (\r\n    status === 'resolved' &&\r\n    options.deleteExistingImages &&\r\n    options.supervisorId\r\n  ) {\r\n    // กลุ่มรูปภาพตามเวลาที่ใกล้เคียง (1 วินาที)\r\n    const grouped = groupImagesByTimestamp(existingImages, 1 * 1000);\r\n    const latestGroup = grouped[0] || [];\r\n\r\n    // กรองเฉพาะรูปของ supervisor ปัจจุบัน\r\n    const authorizedImages = latestGroup.filter(\r\n      img => img.updatedBy === options.supervisorId\r\n    );\r\n    let defect = await prisma.defect.findFirst({\r\n      where: {\r\n        id: defectId\r\n      },\r\n      select: {\r\n        status: true\r\n      }\r\n    })\r\n    defect?.status === 'resolved' as DefectStatus ? await deleteImages(authorizedImages.map(img => img.id)) : undefined\r\n\r\n  }\r\n\r\n\r\n  // อัปโหลดภาพใหม่\r\n  await handleDefectImagesUpload(\r\n    defectId,\r\n    status,\r\n    options.updatedBy,\r\n    options.files\r\n  )\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับลบภาพ defect ออกจากระบบ โดยทำการลบไฟล์ภาพและข้อมูลที่เกี่ยวข้องจากฐานข้อมูล\r\n * Input:\r\n * - imageIds: number[] (อาร์เรย์ของ imageId ที่ต้องการลบ)\r\n * Output:\r\n * - ลบไฟล์ภาพที่เก็บอยู่ในระบบ\r\n * - ลบข้อมูลภาพออกจากฐานข้อมูล รวมถึงการเชื่อมโยงกับ defect\r\n **/\r\nexport const deleteImages = async (imageIds: number[]) => {\r\n  if (imageIds.length === 0) return\r\n\r\n  // ลบไฟล์จากระบบ\r\n  const imagesToDelete = await prisma.image.findMany({\r\n    where: { id: { in: imageIds } },\r\n    select: { path: true },\r\n  })\r\n\r\n  imagesToDelete.forEach((image) => {\r\n    const filePath = path.join(uploadsPath, image.path)\r\n    try {\r\n      fs.unlinkSync(filePath)\r\n    } catch (error) {\r\n      console.error(`Failed to delete file at ${filePath}:`, error)\r\n    }\r\n  })\r\n\r\n  // ลบข้อมูลจากฐานข้อมูล\r\n  await prisma.$transaction([\r\n    prisma.defectImage.deleteMany({\r\n      where: { imageId: { in: imageIds } }\r\n    }),\r\n    prisma.image.deleteMany({\r\n      where: {\r\n        id: { in: imageIds }\r\n      }\r\n    })\r\n  ])\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับส่งอีเมลรีเซ็ตรหัสผ่านให้ผู้ใช้\r\n * Input:\r\n * - req.body.email: string (อีเมลของผู้ใช้ที่ต้องการรีเซ็ตรหัสผ่าน)\r\n * Output:\r\n * - ส่งอีเมลที่มีลิงก์สำหรับการรีเซ็ตรหัสผ่าน\r\n * - หากอีเมลไม่พบในฐานข้อมูลหรือไม่ระบุอีเมล จะมีการตอบกลับด้วยรหัสสถานะที่เหมาะสม\r\n **/\r\nexport async function sendEmailResetPassword(req: Request, res: Response) {\r\n  const { email } = req.body;\r\n\r\n  if (!email) {\r\n    res.status(400).json({ message: \"Email is required\" });\r\n    return\r\n  }\r\n\r\n  const user = await prisma.user.findUnique({ where: { email } });\r\n  if (!user) {\r\n    res.status(404).json({ message: \"User not found\" });\r\n    return\r\n  }\r\n\r\n  const token = randomBytes(32).toString('hex');\r\n  const expiresAt = new Date(Date.now() + 15 * 60 * 1000);\r\n\r\n  await prisma.user.update({\r\n    where: { id: user.id },\r\n    data: {\r\n      resetToken: token,\r\n      resetTokenExpires: expiresAt,\r\n    },\r\n  });\r\n\r\n  // สร้างลิงก์ reset password\r\n  const resetLinkEN = `${process.env.CLIENT_URL}/en/login/forgot-password?token=${token}`;\r\n  const resetLinkTH = `${process.env.CLIENT_URL}/th/login/forgot-password?token=${token}`;\r\n\r\n  // ส่งอีเมล\r\n  const emailSubject = \"Reset Your Password\";\r\n  const emailMessage =\r\n    `Click the link to reset your password: ${resetLinkEN}<hr>\r\n   คลิกลิงก์เพื่อตั้งรหัสผ่านใหม่ของคุณ: ${resetLinkTH}\r\n  `;\r\n\r\n  await sendEmail(email, emailSubject, emailMessage);\r\n\r\n  res.status(200).json({ message: \"Reset password email sent\" });\r\n  return\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับรีเซ็ตรหัสผ่านของผู้ใช้\r\n * Input:\r\n * - req.body.token: string (โทเค็นที่ใช้ในการรีเซ็ตรหัสผ่าน)\r\n * - req.body.newPassword: string (รหัสผ่านใหม่ที่ผู้ใช้ต้องการตั้ง)\r\n * Output:\r\n * - อัปเดตรหัสผ่านของผู้ใช้ในฐานข้อมูลและลบโทเค็นรีเซ็ตรหัสผ่าน\r\n * - หากโทเค็นไม่ถูกต้องหรือผู้ใช้ไม่พบในฐานข้อมูล จะตอบกลับด้วยข้อความแสดงข้อผิดพลาด\r\n **/\r\nexport async function resetForgotPassword(req: Request, res: Response) {\r\n  try {\r\n    const { token, newPassword } = req.body;\r\n\r\n    const user = await prisma.user.findFirst({\r\n      where: { resetToken: token },\r\n      select: {\r\n        id: true,\r\n        password: true,\r\n      }\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(404).json({ message: 'Invalid token or user not found.' });\r\n      return\r\n    }\r\n\r\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n    // อัปเดตผู้ใช้ด้วยรหัสผ่านใหม่และรีเซ็ต token\r\n    await prisma.user.update({\r\n      where: { id: user.id },\r\n      data: {\r\n        password: hashedPassword,\r\n        resetToken: null,\r\n        resetTokenExpires: null\r\n      }\r\n    });\r\n\r\n    res.status(200).json({ message: 'Password successfully updated.', status: 200 });\r\n    return\r\n  } catch (error) {\r\n    console.error('Error resetting password:', error);\r\n    res.status(500).json({ message: 'Server error, please try again later.' });\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * คำอธิบาย: ฟังก์ชันสำหรับตรวจสอบความถูกต้องของโทเค็นการรีเซ็ตรหัสผ่าน\r\n * Input:\r\n * - req.query.token: string (โทเค็นที่ใช้ในการรีเซ็ตรหัสผ่าน)\r\n * Output:\r\n * - ตรวจสอบว่าโทเค็นที่ส่งมาถูกต้องและยังไม่หมดอายุ\r\n * - หากโทเค็นไม่พบหรือหมดอายุ จะตอบกลับด้วยข้อความแสดงข้อผิดพลาด\r\n * - หากโทเค็นถูกต้อง จะตอบกลับสถานะว่า \"Token is valid\"\r\n **/\r\nexport async function verifyToken(req: Request, res: Response) {\r\n  try {\r\n    const token = req.query.token\r\n\r\n    if (!token) {\r\n      res.status(400).json({ message: \"Token is required\" });\r\n      return\r\n    }\r\n\r\n    const user = await prisma.user.findFirst({\r\n      where: { resetToken: token.toString() },\r\n      select: {\r\n        resetTokenExpires: true\r\n      }\r\n    });\r\n\r\n    if (!user) {\r\n      res.status(404).json({ message: \"Token not found or invalid\" });\r\n      return\r\n    }\r\n\r\n    if (user.resetTokenExpires && new Date(user.resetTokenExpires) < new Date()) {\r\n      res.status(404).json({ message: \"Token has expired\" });\r\n      return;\r\n    }\r\n\r\n    res.status(200).json({ status: 200, message: \"Token is valid\" });\r\n  } catch (error) {\r\n    console.error('Error verifying token:', error);\r\n    res.status(500).json({ message: \"Server error\" });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\dashboard-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\defect-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\location-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\patrol-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\preset-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\user-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Routes\\util-route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\_mocks_\\defect.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\_mocks_\\location.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\_mocks_\\patrol.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\_mocks_\\preset.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\_mocks_\\prisma.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\_mocks_\\user.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\_mocks_\\util.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\defect.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\location.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\patrol.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\preset.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\singleton.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\user.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Tests\\util.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createNotificationMock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'notificationMock' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":83}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from \"express\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { authenticateUser, authorized, getAllNotifications, login, logout, markAllAsRead, removeAllNotifications, removeOldNotifications, updateNotification } from \"@Controllers/util-controller.js\";\r\nimport { prismaMock } from \"./_mocks_/prisma.mock\";\r\nimport { allNotificationMock, createNotificationMock, decodeMock, notificationMock, updateNotificationMock, userMock } from \"./_mocks_/util.mock\";\r\n\r\n// Mock Response object\r\nconst mockResponse = (overrides: Partial<Response> = {}) => {\r\n  const res: Partial<Response> = {\r\n    status: jest.fn().mockReturnThis(),\r\n    json: jest.fn().mockReturnThis(),\r\n    cookie: jest.fn().mockReturnThis(),\r\n    clearCookie: jest.fn().mockReturnThis(),\r\n    ...overrides,\r\n  };\r\n  return res as Response;\r\n};\r\n\r\n// Mock Request object\r\nconst mockRequest = (query: any, params: any, body: any, user: any, cookies: any) => {\r\n  return {\r\n    query,\r\n    params,\r\n    body,\r\n    user,\r\n    cookies,\r\n  } as unknown as Request;\r\n};\r\n\r\njest.mock('bcryptjs', () => ({\r\n  compare: jest.fn(),\r\n}));\r\n\r\njest.mock('jsonwebtoken', () => ({\r\n  sign: jest.fn(),\r\n  verify: jest.fn(),\r\n}));\r\n\r\ndescribe('login', () => {\r\n  test('ควรเข้าสู่ระบบได้สำเร็จ', async () => {\r\n    prismaMock.user.findUnique.mockResolvedValue(userMock);\r\n    prismaMock.session.create.mockResolvedValue({\r\n      userId: userMock.id,\r\n      token: \"mockSessionId\",\r\n      expiresAt: new Date(),\r\n    });\r\n    (bcrypt.compare as jest.Mock).mockResolvedValue(true);\r\n    (jwt.sign as jest.Mock).mockReturnValue(\"mockToken\");\r\n\r\n    (global.Date.now as jest.Mock) = jest.fn(() => 1702310400000);\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {\r\n        username: \"testuser\",\r\n        password: \"testpassword\",\r\n        rememberMe: true,\r\n      },\r\n      {},\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await login(req, res);\r\n    expect(bcrypt.compare).toHaveBeenCalledWith(\"testpassword\", \"hashedPassword\");\r\n    expect(jwt.sign).toHaveBeenCalledWith(\r\n      {\r\n        userId: 1,\r\n        role: \"inspector\",\r\n        sessionId: expect.any(String),\r\n\r\n      },\r\n      expect.any(String),\r\n      { expiresIn: \"1h\" }\r\n    );\r\n\r\n    expect(res.cookie).toHaveBeenCalledWith(\"authToken\", \"mockToken\", expect.any(Object));\r\n    expect(res.cookie).toHaveBeenCalledWith(\"refreshToken\", expect.any(String), expect.any(Object));\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith({ message: \"Login Success\", accessToken: \"mockToken\", refreshToken: expect.any(String) });\r\n  });\r\n});\r\n\r\ndescribe('logout', () => {\r\n  test('ควรออกจากระบบได้สำเร็จ', async () => {\r\n    (jwt.verify as jest.Mock).mockReturnValue({ userId: 1, role: \"inspector\" });\r\n    prismaMock.session.deleteMany.mockResolvedValue({ count: 1 });\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      {},\r\n      { authToken: \"mockToken\" });\r\n\r\n    const res = mockResponse();\r\n\r\n    await logout(req, res);\r\n\r\n    expect(res.clearCookie).toHaveBeenCalledWith(\"authToken\", {\r\n      httpOnly: true,\r\n      secure: false,\r\n      sameSite: 'lax',\r\n    });\r\n    expect(res.clearCookie).toHaveBeenCalledWith(\"refreshToken\", expect.objectContaining({\r\n      httpOnly: true,\r\n      secure: false,\r\n      sameSite: 'lax',\r\n    }));\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith({ message: \"Logout successful\" });\r\n  });\r\n});\r\n\r\ndescribe('authenticateUser', () => {\r\n  test('ควรยืนยันตัวตนผู้ใช้งานได้สำเร็จ', async () => {\r\n    (jwt.verify as jest.Mock).mockReturnValue(decodeMock);\r\n    const now = new Date();\r\n    prismaMock.session.findUnique.mockResolvedValue({\r\n      id: 1,\r\n      userId: decodeMock.userId,\r\n      token: decodeMock.sessionId,\r\n      expiresAt: new Date(now.getTime() + 60 * 60 * 1000),\r\n    });\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      {},\r\n      { authToken: \"mockToken\" });\r\n\r\n    const res = mockResponse();\r\n    const next = jest.fn();\r\n\r\n    await authenticateUser(req, res, next);\r\n    expect(req.user).toEqual(decodeMock);\r\n    expect(next).toHaveBeenCalled();\r\n  });\r\n});\r\n\r\ndescribe('getAllNotifications', () => {\r\n  test('ควรดึงข้อมูล Notification ได้ถูกต้อง', async () => {\r\n    prismaMock.notification.findMany.mockResolvedValueOnce(allNotificationMock);\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await getAllNotifications(req, res);\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith(allNotificationMock);\r\n  });\r\n});\r\n\r\n\r\njest.mock('@Utils/socket.js', () => ({\r\n  getIOInstance: jest.fn().mockReturnValue({\r\n    to: jest.fn().mockReturnThis(),\r\n    emit: jest.fn(),\r\n  }),\r\n}));\r\n\r\ndescribe('updateNotification', () => {\r\n  test('ควรเปลี่ยนสถานะ Notification เป็น \"อ่านแล้ว\"', async () => {\r\n    prismaMock.notification.update.mockResolvedValueOnce(updateNotificationMock);\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      { id: 1 },\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await updateNotification(req, res);\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith(updateNotificationMock);\r\n  });\r\n});\r\n\r\ndescribe('markAllAsRead', () => {\r\n  test('ควรเปลี่ยนสถานะ Notification ทั้งหมดเป็น \"อ่านแล้ว\"', async () => {\r\n    prismaMock.notification.updateMany.mockResolvedValueOnce({\r\n      count: 2,\r\n    });\r\n\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      { id: 1 },\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await markAllAsRead(req, res);\r\n    expect(prismaMock.notification.updateMany).toHaveBeenCalledWith({\r\n      where: { userId: 3, read: false },\r\n      data: { read: true },\r\n    });\r\n\r\n    expect(res.status).toHaveBeenCalledWith(200);\r\n    expect(res.json).toHaveBeenCalledWith({ message: \"All notifications marked as read\" });\r\n  });\r\n});\r\n\r\ndescribe('removeOldNotifications', () => {\r\n  beforeAll(() => {\r\n    jest.useFakeTimers().setSystemTime(new Date(\"2025-01-12T15:09:36.718Z\"));\r\n  });\r\n\r\n  afterAll(() => {\r\n    jest.useRealTimers();\r\n  });\r\n  test('ควรลบ Notification ที่เก่ากว่า 7 วัน', async () => {\r\n    prismaMock.notification.deleteMany.mockResolvedValueOnce({\r\n      count: 2,\r\n    });\r\n\r\n\r\n    const sevenDaysAgo = new Date(\"2025-01-12T15:09:36.718Z\");\r\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\r\n\r\n    await removeOldNotifications();\r\n    expect(prismaMock.notification.deleteMany).toHaveBeenCalledWith({\r\n      where: {\r\n        timestamp: {\r\n          lt: sevenDaysAgo,\r\n        },\r\n      },\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('removeAllNotifications', () => {\r\n  test('ควรลบ Notification ทั้งหมดของผู้ใช้', async () => {\r\n    prismaMock.notification.deleteMany.mockResolvedValueOnce({\r\n      count: 2,\r\n    })\r\n    const req = mockRequest(\r\n      {},\r\n      {},\r\n      {},\r\n      { role: \"inspector\", userId: 3 },\r\n      {});\r\n\r\n    const res = mockResponse();\r\n\r\n    await removeAllNotifications(req, res);\r\n    expect(prismaMock.notification.deleteMany).toHaveBeenCalledWith({\r\n      where: {\r\n        userId: 3,\r\n      },\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('authorized', () => {\r\n  test('ควรอนุญาตให้ผู้ใช้ที่มีบทบาทใน allowedRoles ผ่านได้', async () => {\r\n    const allowedRoles = [\"admin\", \"inspector\"];\r\n    const middleware = authorized(allowedRoles);\r\n\r\n    const req = mockRequest({}, {}, {}, { role: \"inspector\", userId: 3 }, {});\r\n    const res = mockResponse();\r\n    const next = jest.fn();\r\n\r\n    middleware(req, res, next);\r\n\r\n    expect(next).toHaveBeenCalled();\r\n    expect(res.status).not.toHaveBeenCalled();\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\cors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\checklists.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\item-zones.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\locations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\patrol-checklists.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\patrols.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\preset-checklist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\presets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\profiles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\users.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\data\\zones.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\Utils\\socket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SE_3\\TEAM6-DENSY\\server\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]